<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Process Scheduling</title>
  <!-- <script type="module" crossorigin src="/assets/index.be1888d4.js"></script> -->
  <link rel="stylesheet" href="./index.bb084d32.css">
</head>

<body>
  <div id="app"></div>
  <script>
    var Yr=Object.defineProperty; var Xr=(e,t,n) => t in e? Yr(e,t,{enumerable: !0,configurable: !0,writable: !0,value: n}):e[t]=n; var de=(e,t,n) => (Xr(e,typeof t!="symbol"? t+"":t,n),n); (function() {const t=document.createElement("link").relList; if(t&&t.supports&&t.supports("modulepreload")) return; for(const r of document.querySelectorAll('link[rel="modulepreload"]')) s(r); new MutationObserver(r => {for(const i of r) if(i.type==="childList") for(const o of i.addedNodes) o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList: !0,subtree: !0}); function n(r) {const i={}; return r.integrity&&(i.integrity=r.integrity),r.referrerpolicy&&(i.referrerPolicy=r.referrerpolicy),r.crossorigin==="use-credentials"? i.credentials="include":r.crossorigin==="anonymous"? i.credentials="omit":i.credentials="same-origin",i} function s(r) {if(r.ep) return; r.ep=!0; const i=n(r); fetch(r.href,i)} })(); function Hn(e,t) {const n=Object.create(null),s=e.split(","); for(let r=0;r<s.length;r++)n[s[r]]=!0; return t? r => !!n[r.toLowerCase()]:r => !!n[r]} const Zr="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",Gr=Hn(Zr); function qs(e) {return !!e||e===""} function rt(e) {if(F(e)) {const t={}; for(let n=0;n<e.length;n++) {const s=e[n],r=te(s)? ni(s):rt(s); if(r) for(const i in r) t[i]=r[i]} return t} else {if(te(e)) return e; if(K(e)) return e} } const ei=/;(?![^(]*\))/g,ti=/:(.+)/; function ni(e) {const t={}; return e.split(ei).forEach(n => {if(n) {const s=n.split(ti); s.length>1&&(t[s[0].trim()]=s[1].trim())} }),t} function Bn(e) {let t=""; if(te(e)) t=e; else if(F(e)) for(let n=0;n<e.length;n++) {const s=Bn(e[n]); s&&(t+=s+" ")} else if(K(e)) for(const n in e) e[n]&&(t+=n+" "); return t.trim()} function si(e,t) {if(e.length!==t.length) return !1; let n=!0; for(let s=0;n&&s<e.length;s++)n=it(e[s],t[s]); return n} function it(e,t) {if(e===t) return !0; let n=hs(e),s=hs(t); if(n||s) return n&&s? e.getTime()===t.getTime():!1; if(n=At(e),s=At(t),n||s) return e===t; if(n=F(e),s=F(t),n||s) return n&&s? si(e,t):!1; if(n=K(e),s=K(t),n||s) {if(!n||!s) return !1; const r=Object.keys(e).length,i=Object.keys(t).length; if(r!==i) return !1; for(const o in e) {const l=e.hasOwnProperty(o),u=t.hasOwnProperty(o); if(l&&!u||!l&&u||!it(e[o],t[o])) return !1} } return String(e)===String(t)} function Un(e,t) {return e.findIndex(n => it(n,t))} const Se=e => te(e)? e:e==null? "":F(e)||K(e)&&(e.toString===Ys||!M(e.toString))? JSON.stringify(e,zs,2):String(e),zs=(e,t) => t&&t.__v_isRef? zs(e,t.value):dt(t)? {[`Map(${t.size})`]: [...t.entries()].reduce((n,[s,r]) => (n[`${s} =>`]=r,n),{})}:yt(t)? {[`Set(${t.size})`]: [...t.values()]}:K(t)&&!F(t)&&!Xs(t)? String(t):t,B={},at=[],we=() => {},ri=() => !1,ii=/^on[^a-z]/,nn=e => ii.test(e),jn=e => e.startsWith("onUpdate:"),re=Object.assign,Dn=(e,t) => {const n=e.indexOf(t); n>-1&&e.splice(n,1)},oi=Object.prototype.hasOwnProperty,k=(e,t) => oi.call(e,t),F=Array.isArray,dt=e => St(e)==="[object Map]",yt=e => St(e)==="[object Set]",hs=e => St(e)==="[object Date]",M=e => typeof e=="function",te=e => typeof e=="string",At=e => typeof e=="symbol",K=e => e!==null&&typeof e=="object",Js=e => K(e)&&M(e.then)&&M(e.catch),Ys=Object.prototype.toString,St=e => Ys.call(e),li=e => St(e).slice(8,-1),Xs=e => St(e)==="[object Object]",Kn=e => te(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,Kt=Hn(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),sn=e => {const t=Object.create(null); return n => t[n]||(t[n]=e(n))},ci=/-(\w)/g,gt=sn(e => e.replace(ci,(t,n) => n? n.toUpperCase():"")),ui=/\B([A-Z])/g,ot=sn(e => e.replace(ui,"-$1").toLowerCase()),Zs=sn(e => e.charAt(0).toUpperCase()+e.slice(1)),mn=sn(e => e? `on${Zs(e)}`:""),It=(e,t) => !Object.is(e,t),Qt=(e,t) => {for(let n=0;n<e.length;n++)e[n](t)},Yt=(e,t,n) => {Object.defineProperty(e,t,{configurable: !0,enumerable: !1,value: n})},Xt=e => {const t=parseFloat(e); return isNaN(t)? e:t}; let ps; const fi=() => ps||(ps=typeof globalThis<"u"? globalThis:typeof self<"u"? self:typeof window<"u"? window:typeof global<"u"? global:{}); let Ie; class ai {constructor(t=!1) {this.detached=t,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Ie,!t&&Ie&&(this.index=(Ie.scopes||(Ie.scopes=[])).push(this)-1)} run(t) {if(this.active) {const n=Ie; try {return Ie=this,t()} finally {Ie=n} } } on() {Ie=this} off() {Ie=this.parent} stop(t) {if(this.active) {let n,s; for(n=0,s=this.effects.length;n<s;n++)this.effects[n].stop(); for(n=0,s=this.cleanups.length;n<s;n++)this.cleanups[n](); if(this.scopes) for(n=0,s=this.scopes.length;n<s;n++)this.scopes[n].stop(!0); if(!this.detached&&this.parent&&!t) {const r=this.parent.scopes.pop(); r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)} this.parent=void 0,this.active=!1} } } function di(e,t=Ie) {t&&t.active&&t.effects.push(e)} const Qn=e => {const t=new Set(e); return t.w=0,t.n=0,t},Gs=e => (e.w&Qe)>0,er=e => (e.n&Qe)>0,hi=({deps: e}) => {if(e.length) for(let t=0;t<e.length;t++)e[t].w|=Qe},pi=e => {const {deps: t}=e; if(t.length) {let n=0; for(let s=0;s<t.length;s++) {const r=t[s]; Gs(r)&&!er(r)? r.delete(e):t[n++]=r,r.w&=~Qe,r.n&=~Qe} t.length=n} },Cn=new WeakMap; let vt=0,Qe=1; const vn=30; let _e; const nt=Symbol(""),En=Symbol(""); class Wn {constructor(t,n=null,s) {this.fn=t,this.scheduler=n,this.active=!0,this.deps=[],this.parent=void 0,di(this,s)} run() {if(!this.active) return this.fn(); let t=_e,n=je; for(;t;) {if(t===this) return; t=t.parent} try {return this.parent=_e,_e=this,je=!0,Qe=1<<++vt,vt<=vn? hi(this):gs(this),this.fn()} finally {vt<=vn&&pi(this),Qe=1<<--vt,_e=this.parent,je=n,this.parent=void 0,this.deferStop&&this.stop()} } stop() {_e===this? this.deferStop=!0:this.active&&(gs(this),this.onStop&&this.onStop(),this.active=!1)} } function gs(e) {const {deps: t}=e; if(t.length) {for(let n=0;n<t.length;n++)t[n].delete(e); t.length=0} } let je=!0; const tr=[]; function xt() {tr.push(je),je=!1} function wt() {const e=tr.pop(); je=e===void 0? !0:e} function he(e,t,n) {if(je&&_e) {let s=Cn.get(e); s||Cn.set(e,s=new Map); let r=s.get(n); r||s.set(n,r=Qn()),nr(r)} } function nr(e,t) {let n=!1; vt<=vn? er(e)||(e.n|=Qe,n=!Gs(e)):n=!e.has(_e),n&&(e.add(_e),_e.deps.push(e))} function $e(e,t,n,s,r,i) {const o=Cn.get(e); if(!o) return; let l=[]; if(t==="clear") l=[...o.values()]; else if(n==="length"&&F(e)) o.forEach((u,a) => {(a==="length"||a>=s)&&l.push(u)}); else switch(n!==void 0&&l.push(o.get(n)),t) {case "add": F(e)? Kn(n)&&l.push(o.get("length")):(l.push(o.get(nt)),dt(e)&&l.push(o.get(En))); break; case "delete": F(e)||(l.push(o.get(nt)),dt(e)&&l.push(o.get(En))); break; case "set": dt(e)&&l.push(o.get(nt)); break}if(l.length===1) l[0]&&Fn(l[0]); else {const u=[]; for(const a of l) a&&u.push(...a); Fn(Qn(u))} } function Fn(e,t) {const n=F(e)? e:[...e]; for(const s of n) s.computed&&ms(s); for(const s of n) s.computed||ms(s)} function ms(e,t) {(e!==_e||e.allowRecurse)&&(e.scheduler? e.scheduler():e.run())} const gi=Hn("__proto__,__v_isRef,__isVue"),sr=new Set(Object.getOwnPropertyNames(Symbol).filter(e => e!=="arguments"&&e!=="caller").map(e => Symbol[e]).filter(At)),mi=Vn(),bi=Vn(!1,!0),_i=Vn(!0),bs=yi(); function yi() {const e={}; return ["includes","indexOf","lastIndexOf"].forEach(t => {e[t]=function(...n) {const s=$(this); for(let i=0,o=this.length;i<o;i++)he(s,"get",i+""); const r=s[t](...n); return r===-1||r===!1? s[t](...n.map($)):r}}),["push","pop","shift","unshift","splice"].forEach(t => {e[t]=function(...n) {xt(); const s=$(this)[t].apply(this,n); return wt(),s}}),e} function Vn(e=!1,t=!1) {return function(s,r,i) {if(r==="__v_isReactive") return !e; if(r==="__v_isReadonly") return e; if(r==="__v_isShallow") return t; if(r==="__v_raw"&&i===(e? t? Li:cr:t? lr:or).get(s)) return s; const o=F(s); if(!e&&o&&k(bs,r)) return Reflect.get(bs,r,i); const l=Reflect.get(s,r,i); return (At(r)? sr.has(r):gi(r))||(e||he(s,"get",r),t)? l:ee(l)? o&&Kn(r)? l:l.value:K(l)? e? ur(l):Jn(l):l}} const xi=rr(),wi=rr(!0); function rr(e=!1) {return function(n,s,r,i) {let o=n[s]; if(mt(o)&&ee(o)&&!ee(r)) return !1; if(!e&&(!Zt(r)&&!mt(r)&&(o=$(o),r=$(r)),!F(n)&&ee(o)&&!ee(r))) return o.value=r,!0; const l=F(n)&&Kn(s)? Number(s)<n.length:k(n,s),u=Reflect.set(n,s,r,i); return n===$(i)&&(l? It(r,o)&&$e(n,"set",s,r):$e(n,"add",s,r)),u}} function Ti(e,t) {const n=k(e,t); e[t]; const s=Reflect.deleteProperty(e,t); return s&&n&&$e(e,"delete",t,void 0),s} function Ci(e,t) {const n=Reflect.has(e,t); return (!At(t)||!sr.has(t))&&he(e,"has",t),n} function vi(e) {return he(e,"iterate",F(e)? "length":nt),Reflect.ownKeys(e)} const ir={get: mi,set: xi,deleteProperty: Ti,has: Ci,ownKeys: vi},Ei={get: _i,set(e,t) {return !0},deleteProperty(e,t) {return !0} },Fi=re({},ir,{get: bi,set: wi}),qn=e => e,rn=e => Reflect.getPrototypeOf(e); function Nt(e,t,n=!1,s=!1) {e=e.__v_raw; const r=$(e),i=$(t); n||(t!==i&&he(r,"get",t),he(r,"get",i)); const {has: o}=rn(r),l=s? qn:n? Xn:Pt; if(o.call(r,t)) return l(e.get(t)); if(o.call(r,i)) return l(e.get(i)); e!==r&&e.get(t)} function Ht(e,t=!1) {const n=this.__v_raw,s=$(n),r=$(e); return t||(e!==r&&he(s,"has",e),he(s,"has",r)),e===r? n.has(e):n.has(e)||n.has(r)} function Bt(e,t=!1) {return e=e.__v_raw,!t&&he($(e),"iterate",nt),Reflect.get(e,"size",e)} function _s(e) {e=$(e); const t=$(this); return rn(t).has.call(t,e)||(t.add(e),$e(t,"add",e,e)),this} function ys(e,t) {t=$(t); const n=$(this),{has: s,get: r}=rn(n); let i=s.call(n,e); i||(e=$(e),i=s.call(n,e)); const o=r.call(n,e); return n.set(e,t),i? It(t,o)&&$e(n,"set",e,t):$e(n,"add",e,t),this} function xs(e) {const t=$(this),{has: n,get: s}=rn(t); let r=n.call(t,e); r||(e=$(e),r=n.call(t,e)),s&&s.call(t,e); const i=t.delete(e); return r&&$e(t,"delete",e,void 0),i} function ws() {const e=$(this),t=e.size!==0,n=e.clear(); return t&&$e(e,"clear",void 0,void 0),n} function Ut(e,t) {return function(s,r) {const i=this,o=i.__v_raw,l=$(o),u=t? qn:e? Xn:Pt; return !e&&he(l,"iterate",nt),o.forEach((a,p) => s.call(r,u(a),u(p),i))}} function jt(e,t,n) {return function(...s) {const r=this.__v_raw,i=$(r),o=dt(i),l=e==="entries"||e===Symbol.iterator&&o,u=e==="keys"&&o,a=r[e](...s),p=n? qn:t? Xn:Pt; return !t&&he(i,"iterate",u? En:nt),{next() {const {value: y,done: T}=a.next(); return T? {value: y,done: T}:{value: l? [p(y[0]),p(y[1])]:p(y),done: T}},[Symbol.iterator]() {return this} }}} function Be(e) {return function(...t) {return e==="delete"? !1:this}} function Ai() {const e={get(i) {return Nt(this,i)},get size() {return Bt(this)},has: Ht,add: _s,set: ys,delete: xs,clear: ws,forEach: Ut(!1,!1)},t={get(i) {return Nt(this,i,!1,!0)},get size() {return Bt(this)},has: Ht,add: _s,set: ys,delete: xs,clear: ws,forEach: Ut(!1,!0)},n={get(i) {return Nt(this,i,!0)},get size() {return Bt(this,!0)},has(i) {return Ht.call(this,i,!0)},add: Be("add"),set: Be("set"),delete: Be("delete"),clear: Be("clear"),forEach: Ut(!0,!1)},s={get(i) {return Nt(this,i,!0,!0)},get size() {return Bt(this,!0)},has(i) {return Ht.call(this,i,!0)},add: Be("add"),set: Be("set"),delete: Be("delete"),clear: Be("clear"),forEach: Ut(!0,!0)}; return ["keys","values","entries",Symbol.iterator].forEach(i => {e[i]=jt(i,!1,!1),n[i]=jt(i,!0,!1),t[i]=jt(i,!1,!0),s[i]=jt(i,!0,!0)}),[e,n,t,s]} const [Ii,Pi,Mi,Oi]=Ai(); function zn(e,t) {const n=t? e? Oi:Mi:e? Pi:Ii; return (s,r,i) => r==="__v_isReactive"? !e:r==="__v_isReadonly"? e:r==="__v_raw"? s:Reflect.get(k(n,r)&&r in s? n:s,r,i)} const Ri={get: zn(!1,!1)},ki={get: zn(!1,!0)},Si={get: zn(!0,!1)},or=new WeakMap,lr=new WeakMap,cr=new WeakMap,Li=new WeakMap; function $i(e) {switch(e) {case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0}} function Ni(e) {return e.__v_skip||!Object.isExtensible(e)? 0:$i(li(e))} function Jn(e) {return mt(e)? e:Yn(e,!1,ir,Ri,or)} function Hi(e) {return Yn(e,!1,Fi,ki,lr)} function ur(e) {return Yn(e,!0,Ei,Si,cr)} function Yn(e,t,n,s,r) {if(!K(e)||e.__v_raw&&!(t&&e.__v_isReactive)) return e; const i=r.get(e); if(i) return i; const o=Ni(e); if(o===0) return e; const l=new Proxy(e,o===2? s:n); return r.set(e,l),l} function ht(e) {return mt(e)? ht(e.__v_raw):!!(e&&e.__v_isReactive)} function mt(e) {return !!(e&&e.__v_isReadonly)} function Zt(e) {return !!(e&&e.__v_isShallow)} function fr(e) {return ht(e)||mt(e)} function $(e) {const t=e&&e.__v_raw; return t? $(t):e} function ar(e) {return Yt(e,"__v_skip",!0),e} const Pt=e => K(e)? Jn(e):e,Xn=e => K(e)? ur(e):e; function dr(e) {je&&_e&&(e=$(e),nr(e.dep||(e.dep=Qn())))} function hr(e,t) {e=$(e),e.dep&&Fn(e.dep)} function ee(e) {return !!(e&&e.__v_isRef===!0)} function Wt(e) {return Bi(e,!1)} function Bi(e,t) {return ee(e)? e:new Ui(e,t)} class Ui {constructor(t,n) {this.__v_isShallow=n,this.dep=void 0,this.__v_isRef=!0,this._rawValue=n? t:$(t),this._value=n? t:Pt(t)} get value() {return dr(this),this._value} set value(t) {const n=this.__v_isShallow||Zt(t)||mt(t); t=n? t:$(t),It(t,this._rawValue)&&(this._rawValue=t,this._value=n? t:Pt(t),hr(this))} } function q(e) {return ee(e)? e.value:e} const ji={get: (e,t,n) => q(Reflect.get(e,t,n)),set: (e,t,n,s) => {const r=e[t]; return ee(r)&&!ee(n)? (r.value=n,!0):Reflect.set(e,t,n,s)}}; function pr(e) {return ht(e)? e:new Proxy(e,ji)} var gr; class Di {constructor(t,n,s,r) {this._setter=n,this.dep=void 0,this.__v_isRef=!0,this[gr]=!1,this._dirty=!0,this.effect=new Wn(t,() => {this._dirty||(this._dirty=!0,hr(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!r,this.__v_isReadonly=s} get value() {const t=$(this); return dr(t),(t._dirty||!t._cacheable)&&(t._dirty=!1,t._value=t.effect.run()),t._value} set value(t) {this._setter(t)} } gr="__v_isReadonly"; function Ki(e,t,n=!1) {let s,r; const i=M(e); return i? (s=e,r=we):(s=e.get,r=e.set),new Di(s,r,i||!r,n)} function De(e,t,n,s) {let r; try {r=s? e(...s):e()} catch(i) {on(i,t,n)} return r} function ge(e,t,n,s) {if(M(e)) {const i=De(e,t,n,s); return i&&Js(i)&&i.catch(o => {on(o,t,n)}),i} const r=[]; for(let i=0;i<e.length;i++)r.push(ge(e[i],t,n,s)); return r} function on(e,t,n,s=!0) {const r=t? t.vnode:null; if(t) {let i=t.parent; const o=t.proxy,l=n; for(;i;) {const a=i.ec; if(a) {for(let p=0;p<a.length;p++)if(a[p](e,o,l)===!1) return } i=i.parent} const u=t.appContext.config.errorHandler; if(u) {De(u,null,10,[e,o,l]); return } } Qi(e,n,r,s)} function Qi(e,t,n,s=!0) {console.error(e)} let Mt=!1,An=!1; const se=[]; let Me=0; const pt=[]; let ke=null,Ze=0; const mr=Promise.resolve(); let Zn=null; function Wi(e) {const t=Zn||mr; return e? t.then(this? e.bind(this):e):t} function Vi(e) {let t=Me+1,n=se.length; for(;t<n;) {const s=t+n>>>1; Ot(se[s])<e? t=s+1:n=s} return t} function Gn(e) {(!se.length||!se.includes(e,Mt&&e.allowRecurse? Me+1:Me))&&(e.id==null? se.push(e):se.splice(Vi(e.id),0,e),br())} function br() {!Mt&&!An&&(An=!0,Zn=mr.then(yr))} function qi(e) {const t=se.indexOf(e); t>Me&&se.splice(t,1)} function zi(e) {F(e)? pt.push(...e):(!ke||!ke.includes(e,e.allowRecurse? Ze+1:Ze))&&pt.push(e),br()} function Ts(e,t=Mt? Me+1:0) {for(;t<se.length;t++) {const n=se[t]; n&&n.pre&&(se.splice(t,1),t--,n())} } function _r(e) {if(pt.length) {const t=[...new Set(pt)]; if(pt.length=0,ke) {ke.push(...t); return } for(ke=t,ke.sort((n,s) => Ot(n)-Ot(s)),Ze=0;Ze<ke.length;Ze++)ke[Ze](); ke=null,Ze=0} } const Ot=e => e.id==null? 1/0:e.id,Ji=(e,t) => {const n=Ot(e)-Ot(t); if(n===0) {if(e.pre&&!t.pre) return -1; if(t.pre&&!e.pre) return 1} return n}; function yr(e) {An=!1,Mt=!0,se.sort(Ji); const t=we; try {for(Me=0;Me<se.length;Me++) {const n=se[Me]; n&&n.active!==!1&&De(n,null,14)} } finally {Me=0,se.length=0,_r(),Mt=!1,Zn=null,(se.length||pt.length)&&yr()} } function Yi(e,t,...n) {if(e.isUnmounted) return; const s=e.vnode.props||B; let r=n; const i=t.startsWith("update:"),o=i&&t.slice(7); if(o&&o in s) {const p=`${o==="modelValue"? "model":o}Modifiers`,{number: y,trim: T}=s[p]||B; T&&(r=n.map(A => A.trim())),y&&(r=n.map(Xt))} let l,u=s[l=mn(t)]||s[l=mn(gt(t))]; !u&&i&&(u=s[l=mn(ot(t))]),u&&ge(u,e,6,r); const a=s[l+"Once"]; if(a) {if(!e.emitted) e.emitted={}; else if(e.emitted[l]) return; e.emitted[l]=!0,ge(a,e,6,r)} } function xr(e,t,n=!1) {const s=t.emitsCache,r=s.get(e); if(r!==void 0) return r; const i=e.emits; let o={},l=!1; if(!M(e)) {const u=a => {const p=xr(a,t,!0); p&&(l=!0,re(o,p))}; !n&&t.mixins.length&&t.mixins.forEach(u),e.extends&&u(e.extends),e.mixins&&e.mixins.forEach(u)} return !i&&!l? (K(e)&&s.set(e,null),null):(F(i)? i.forEach(u => o[u]=null):re(o,i),K(e)&&s.set(e,o),o)} function ln(e,t) {return !e||!nn(t)? !1:(t=t.slice(2).replace(/Once$/,""),k(e,t[0].toLowerCase()+t.slice(1))||k(e,ot(t))||k(e,t))} let ye=null,wr=null; function Gt(e) {const t=ye; return ye=e,wr=e&&e.type.__scopeId||null,t} function Xi(e,t=ye,n) {if(!t||e._n) return e; const s=(...r) => {s._d&&Rs(-1); const i=Gt(t); let o; try {o=e(...r)} finally {Gt(i),s._d&&Rs(1)} return o}; return s._n=!0,s._c=!0,s._d=!0,s} function bn(e) {const {type: t,vnode: n,proxy: s,withProxy: r,props: i,propsOptions: [o],slots: l,attrs: u,emit: a,render: p,renderCache: y,data: T,setupState: A,ctx: N,inheritAttrs: P}=e; let U,S; const me=Gt(e); try {if(n.shapeFlag&4) {const z=r||s; U=Pe(p.call(z,z,y,i,A,T,N)),S=u} else {const z=t; U=Pe(z.length>1? z(i,{attrs: u,slots: l,emit: a}):z(i,null)),S=t.props? u:Zi(u)} } catch(z) {Et.length=0,on(z,e,1),U=Ce(Te)} let X=U; if(S&&P!==!1) {const z=Object.keys(S),{shapeFlag: le}=X; z.length&&le&7&&(o&&z.some(jn)&&(S=Gi(S,o)),X=We(X,S))} return n.dirs&&(X=We(X),X.dirs=X.dirs? X.dirs.concat(n.dirs):n.dirs),n.transition&&(X.transition=n.transition),U=X,Gt(me),U} const Zi=e => {let t; for(const n in e) (n==="class"||n==="style"||nn(n))&&((t||(t={}))[n]=e[n]); return t},Gi=(e,t) => {const n={}; for(const s in e) (!jn(s)||!(s.slice(9) in t))&&(n[s]=e[s]); return n}; function eo(e,t,n) {const {props: s,children: r,component: i}=e,{props: o,children: l,patchFlag: u}=t,a=i.emitsOptions; if(t.dirs||t.transition) return !0; if(n&&u>=0) {if(u&1024) return !0; if(u&16) return s? Cs(s,o,a):!!o; if(u&8) {const p=t.dynamicProps; for(let y=0;y<p.length;y++) {const T=p[y]; if(o[T]!==s[T]&&!ln(a,T)) return !0} } } else return (r||l)&&(!l||!l.$stable)? !0:s===o? !1:s? o? Cs(s,o,a):!0:!!o; return !1} function Cs(e,t,n) {const s=Object.keys(t); if(s.length!==Object.keys(e).length) return !0; for(let r=0;r<s.length;r++) {const i=s[r]; if(t[i]!==e[i]&&!ln(n,i)) return !0} return !1} function to({vnode: e,parent: t},n) {for(;t&&t.subTree===e;)(e=t.vnode).el=n,t=t.parent} const no=e => e.__isSuspense; function so(e,t) {t&&t.pendingBranch? F(e)? t.effects.push(...e):t.effects.push(e):zi(e)} function ro(e,t) {if(ne) {let n=ne.provides; const s=ne.parent&&ne.parent.provides; s===n&&(n=ne.provides=Object.create(s)),n[e]=t} } function _n(e,t,n=!1) {const s=ne||ye; if(s) {const r=s.parent==null? s.vnode.appContext&&s.vnode.appContext.provides:s.parent.provides; if(r&&e in r) return r[e]; if(arguments.length>1) return n&&M(t)? t.call(s.proxy):t} } const vs={}; function Vt(e,t,n) {return Tr(e,t,n)} function Tr(e,t,{immediate: n,deep: s,flush: r,onTrack: i,onTrigger: o}=B) {const l=ne; let u,a=!1,p=!1; if(ee(e)? (u=() => e.value,a=Zt(e)):ht(e)? (u=() => e,s=!0):F(e)? (p=!0,a=e.some(S => ht(S)||Zt(S)),u=() => e.map(S => {if(ee(S)) return S.value; if(ht(S)) return tt(S); if(M(S)) return De(S,l,2)})):M(e)? t? u=() => De(e,l,2):u=() => {if(!(l&&l.isUnmounted)) return y&&y(),ge(e,l,3,[T])}:u=we,t&&s) {const S=u; u=() => tt(S())} let y,T=S => {y=U.onStop=() => {De(S,l,4)}}; if(kt) return T=we,t? n&&ge(t,l,3,[u(),p? []:void 0,T]):u(),we; let A=p? []:vs; const N=() => {if(!!U.active) if(t) {const S=U.run(); (s||a||(p? S.some((me,X) => It(me,A[X])):It(S,A)))&&(y&&y(),ge(t,l,3,[S,A===vs? void 0:A,T]),A=S)} else U.run()}; N.allowRecurse=!!t; let P; r==="sync"? P=N:r==="post"? P=() => ce(N,l&&l.suspense):(N.pre=!0,l&&(N.id=l.uid),P=() => Gn(N)); const U=new Wn(u,P); return t? n? N():A=U.run():r==="post"? ce(U.run.bind(U),l&&l.suspense):U.run(),() => {U.stop(),l&&l.scope&&Dn(l.scope.effects,U)}} function io(e,t,n) {const s=this.proxy,r=te(e)? e.includes(".")? Cr(s,e):() => s[e]:e.bind(s,s); let i; M(t)? i=t:(i=t.handler,n=t); const o=ne; bt(this); const l=Tr(r,i.bind(s),n); return o? bt(o):st(),l} function Cr(e,t) {const n=t.split("."); return () => {let s=e; for(let r=0;r<n.length&&s;r++)s=s[n[r]]; return s}} function tt(e,t) {if(!K(e)||e.__v_skip||(t=t||new Set,t.has(e))) return e; if(t.add(e),ee(e)) tt(e.value,t); else if(F(e)) for(let n=0;n<e.length;n++)tt(e[n],t); else if(yt(e)||dt(e)) e.forEach(n => {tt(n,t)}); else if(Xs(e)) for(const n in e) tt(e[n],t); return e} function oo() {const e={isMounted: !1,isLeaving: !1,isUnmounting: !1,leavingVNodes: new Map}; return Ar(() => {e.isMounted=!0}),Ir(() => {e.isUnmounting=!0}),e} const pe=[Function,Array],lo={name: "BaseTransition",props: {mode: String,appear: Boolean,persisted: Boolean,onBeforeEnter: pe,onEnter: pe,onAfterEnter: pe,onEnterCancelled: pe,onBeforeLeave: pe,onLeave: pe,onAfterLeave: pe,onLeaveCancelled: pe,onBeforeAppear: pe,onAppear: pe,onAfterAppear: pe,onAppearCancelled: pe},setup(e,{slots: t}) {const n=Vo(),s=oo(); let r; return () => {const i=t.default&&Er(t.default(),!0); if(!i||!i.length) return; let o=i[0]; if(i.length>1) {for(const P of i) if(P.type!==Te) {o=P; break} } const l=$(e),{mode: u}=l; if(s.isLeaving) return yn(o); const a=Es(o); if(!a) return yn(o); const p=In(a,l,s,n); Pn(a,p); const y=n.subTree,T=y&&Es(y); let A=!1; const {getTransitionKey: N}=a.type; if(N) {const P=N(); r===void 0? r=P:P!==r&&(r=P,A=!0)} if(T&&T.type!==Te&&(!Ge(a,T)||A)) {const P=In(T,l,s,n); if(Pn(T,P),u==="out-in") return s.isLeaving=!0,P.afterLeave=() => {s.isLeaving=!1,n.update()},yn(o); u==="in-out"&&a.type!==Te&&(P.delayLeave=(U,S,me) => {const X=vr(s,T); X[String(T.key)]=T,U._leaveCb=() => {S(),U._leaveCb=void 0,delete p.delayedLeave},p.delayedLeave=me})} return o}} },co=lo; function vr(e,t) {const {leavingVNodes: n}=e; let s=n.get(t.type); return s||(s=Object.create(null),n.set(t.type,s)),s} function In(e,t,n,s) {const {appear: r,mode: i,persisted: o=!1,onBeforeEnter: l,onEnter: u,onAfterEnter: a,onEnterCancelled: p,onBeforeLeave: y,onLeave: T,onAfterLeave: A,onLeaveCancelled: N,onBeforeAppear: P,onAppear: U,onAfterAppear: S,onAppearCancelled: me}=t,X=String(e.key),z=vr(n,e),le=(O,Z) => {O&&ge(O,s,9,Z)},lt=(O,Z) => {const Q=Z[1]; le(O,Z),F(O)? O.every(fe => fe.length<=1)&&Q():O.length<=1&&Q()},He={mode: i,persisted: o,beforeEnter(O) {let Z=l; if(!n.isMounted) if(r) Z=P||l; else return; O._leaveCb&&O._leaveCb(!0); const Q=z[X]; Q&&Ge(e,Q)&&Q.el._leaveCb&&Q.el._leaveCb(),le(Z,[O])},enter(O) {let Z=u,Q=a,fe=p; if(!n.isMounted) if(r) Z=U||u,Q=S||a,fe=me||p; else return; let ve=!1; const Oe=O._enterCb=Tt => {ve||(ve=!0,Tt? le(fe,[O]):le(Q,[O]),He.delayedLeave&&He.delayedLeave(),O._enterCb=void 0)}; Z? lt(Z,[O,Oe]):Oe()},leave(O,Z) {const Q=String(e.key); if(O._enterCb&&O._enterCb(!0),n.isUnmounting) return Z(); le(y,[O]); let fe=!1; const ve=O._leaveCb=Oe => {fe||(fe=!0,Z(),Oe? le(N,[O]):le(A,[O]),O._leaveCb=void 0,z[Q]===e&&delete z[Q])}; z[Q]=e,T? lt(T,[O,ve]):ve()},clone(O) {return In(O,t,n,s)} }; return He} function yn(e) {if(un(e)) return e=We(e),e.children=null,e} function Es(e) {return un(e)? e.children? e.children[0]:void 0:e} function Pn(e,t) {e.shapeFlag&6&&e.component? Pn(e.component.subTree,t):e.shapeFlag&128? (e.ssContent.transition=t.clone(e.ssContent),e.ssFallback.transition=t.clone(e.ssFallback)):e.transition=t} function Er(e,t=!1,n) {let s=[],r=0; for(let i=0;i<e.length;i++) {let o=e[i]; const l=n==null? o.key:String(n)+String(o.key!=null? o.key:i); o.type===G? (o.patchFlag&128&&r++,s=s.concat(Er(o.children,t,l))):(t||o.type!==Te)&&s.push(l!=null? We(o,{key: l}):o)} if(r>1) for(let i=0;i<s.length;i++)s[i].patchFlag=-2; return s} function cn(e) {return M(e)? {setup: e,name: e.name}:e} const qt=e => !!e.type.__asyncLoader,un=e => e.type.__isKeepAlive; function uo(e,t) {Fr(e,"a",t)} function fo(e,t) {Fr(e,"da",t)} function Fr(e,t,n=ne) {const s=e.__wdc||(e.__wdc=() => {let r=n; for(;r;) {if(r.isDeactivated) return; r=r.parent} return e()}); if(fn(t,s,n),n) {let r=n.parent; for(;r&&r.parent;)un(r.parent.vnode)&&ao(s,t,n,r),r=r.parent} } function ao(e,t,n,s) {const r=fn(t,e,s,!0); Pr(() => {Dn(s[t],r)},n)} function fn(e,t,n=ne,s=!1) {if(n) {const r=n[e]||(n[e]=[]),i=t.__weh||(t.__weh=(...o) => {if(n.isUnmounted) return; xt(),bt(n); const l=ge(t,n,e,o); return st(),wt(),l}); return s? r.unshift(i):r.push(i),i} } const Ne=e => (t,n=ne) => (!kt||e==="sp")&&fn(e,(...s) => t(...s),n),ho=Ne("bm"),Ar=Ne("m"),po=Ne("bu"),go=Ne("u"),Ir=Ne("bum"),Pr=Ne("um"),mo=Ne("sp"),bo=Ne("rtg"),_o=Ne("rtc"); function yo(e,t=ne) {fn("ec",e,t)} function es(e,t) {const n=ye; if(n===null) return e; const s=dn(n)||n.proxy,r=e.dirs||(e.dirs=[]); for(let i=0;i<t.length;i++) {let [o,l,u,a=B]=t[i]; M(o)&&(o={mounted: o,updated: o}),o.deep&&tt(l),r.push({dir: o,instance: s,value: l,oldValue: void 0,arg: u,modifiers: a})} return e} function Je(e,t,n,s) {const r=e.dirs,i=t&&t.dirs; for(let o=0;o<r.length;o++) {const l=r[o]; i&&(l.oldValue=i[o].value); let u=l.dir[s]; u&&(xt(),ge(u,n,8,[e.el,l,e,t]),wt())} } const xo=Symbol(); function Ke(e,t,n,s) {let r; const i=n&&n[s]; if(F(e)||te(e)) {r=new Array(e.length); for(let o=0,l=e.length;o<l;o++)r[o]=t(e[o],o,void 0,i&&i[o])} else if(typeof e=="number") {r=new Array(e); for(let o=0;o<e;o++)r[o]=t(o+1,o,void 0,i&&i[o])} else if(K(e)) if(e[Symbol.iterator]) r=Array.from(e,(o,l) => t(o,l,void 0,i&&i[l])); else {const o=Object.keys(e); r=new Array(o.length); for(let l=0,u=o.length;l<u;l++) {const a=o[l]; r[l]=t(e[a],a,l,i&&i[l])} } else r=[]; return n&&(n[s]=r),r} const Mn=e => e? Dr(e)? dn(e)||e.proxy:Mn(e.parent):null,en=re(Object.create(null),{$: e => e,$el: e => e.vnode.el,$data: e => e.data,$props: e => e.props,$attrs: e => e.attrs,$slots: e => e.slots,$refs: e => e.refs,$parent: e => Mn(e.parent),$root: e => Mn(e.root),$emit: e => e.emit,$options: e => ts(e),$forceUpdate: e => e.f||(e.f=() => Gn(e.update)),$nextTick: e => e.n||(e.n=Wi.bind(e.proxy)),$watch: e => io.bind(e)}),wo={get({_: e},t) {const {ctx: n,setupState: s,data: r,props: i,accessCache: o,type: l,appContext: u}=e; let a; if(t[0]!=="$") {const A=o[t]; if(A!==void 0) switch(A) {case 1: return s[t]; case 2: return r[t]; case 4: return n[t]; case 3: return i[t]} else {if(s!==B&&k(s,t)) return o[t]=1,s[t]; if(r!==B&&k(r,t)) return o[t]=2,r[t]; if((a=e.propsOptions[0])&&k(a,t)) return o[t]=3,i[t]; if(n!==B&&k(n,t)) return o[t]=4,n[t]; On&&(o[t]=0)} } const p=en[t]; let y,T; if(p) return t==="$attrs"&&he(e,"get",t),p(e); if((y=l.__cssModules)&&(y=y[t])) return y; if(n!==B&&k(n,t)) return o[t]=4,n[t]; if(T=u.config.globalProperties,k(T,t)) return T[t]},set({_: e},t,n) {const {data: s,setupState: r,ctx: i}=e; return r!==B&&k(r,t)? (r[t]=n,!0):s!==B&&k(s,t)? (s[t]=n,!0):k(e.props,t)||t[0]==="$"&&t.slice(1) in e? !1:(i[t]=n,!0)},has({_: {data: e,setupState: t,accessCache: n,ctx: s,appContext: r,propsOptions: i}},o) {let l; return !!n[o]||e!==B&&k(e,o)||t!==B&&k(t,o)||(l=i[0])&&k(l,o)||k(s,o)||k(en,o)||k(r.config.globalProperties,o)},defineProperty(e,t,n) {return n.get!=null? e._.accessCache[t]=0:k(n,"value")&&this.set(e,t,n.value,null),Reflect.defineProperty(e,t,n)} }; let On=!0; function To(e) {const t=ts(e),n=e.proxy,s=e.ctx; On=!1,t.beforeCreate&&Fs(t.beforeCreate,e,"bc"); const {data: r,computed: i,methods: o,watch: l,provide: u,inject: a,created: p,beforeMount: y,mounted: T,beforeUpdate: A,updated: N,activated: P,deactivated: U,beforeDestroy: S,beforeUnmount: me,destroyed: X,unmounted: z,render: le,renderTracked: lt,renderTriggered: He,errorCaptured: O,serverPrefetch: Z,expose: Q,inheritAttrs: fe,components: ve,directives: Oe,filters: Tt}=t; if(a&&Co(a,s,null,e.appContext.config.unwrapInjectedRef),o) for(const W in o) {const j=o[W]; M(j)&&(s[W]=j.bind(n))} if(r) {const W=r.call(n,n); K(W)&&(e.data=Jn(W))} if(On=!0,i) for(const W in i) {const j=i[W],qe=M(j)? j.bind(n,n):M(j.get)? j.get.bind(n,n):we,Lt=!M(j)&&M(j.set)? j.set.bind(n):we,ze=Ft({get: qe,set: Lt}); Object.defineProperty(s,W,{enumerable: !0,configurable: !0,get: () => ze.value,set: Ee => ze.value=Ee})} if(l) for(const W in l) Mr(l[W],s,n,W); if(u) {const W=M(u)? u.call(n):u; Reflect.ownKeys(W).forEach(j => {ro(j,W[j])})} p&&Fs(p,e,"c"); function ie(W,j) {F(j)? j.forEach(qe => W(qe.bind(n))):j&&W(j.bind(n))} if(ie(ho,y),ie(Ar,T),ie(po,A),ie(go,N),ie(uo,P),ie(fo,U),ie(yo,O),ie(_o,lt),ie(bo,He),ie(Ir,me),ie(Pr,z),ie(mo,Z),F(Q)) if(Q.length) {const W=e.exposed||(e.exposed={}); Q.forEach(j => {Object.defineProperty(W,j,{get: () => n[j],set: qe => n[j]=qe})})} else e.exposed||(e.exposed={}); le&&e.render===we&&(e.render=le),fe!=null&&(e.inheritAttrs=fe),ve&&(e.components=ve),Oe&&(e.directives=Oe)} function Co(e,t,n=we,s=!1) {F(e)&&(e=Rn(e)); for(const r in e) {const i=e[r]; let o; K(i)? "default" in i? o=_n(i.from||r,i.default,!0):o=_n(i.from||r):o=_n(i),ee(o)&&s? Object.defineProperty(t,r,{enumerable: !0,configurable: !0,get: () => o.value,set: l => o.value=l}):t[r]=o} } function Fs(e,t,n) {ge(F(e)? e.map(s => s.bind(t.proxy)):e.bind(t.proxy),t,n)} function Mr(e,t,n,s) {const r=s.includes(".")? Cr(n,s):() => n[s]; if(te(e)) {const i=t[e]; M(i)&&Vt(r,i)} else if(M(e)) Vt(r,e.bind(n)); else if(K(e)) if(F(e)) e.forEach(i => Mr(i,t,n,s)); else {const i=M(e.handler)? e.handler.bind(n):t[e.handler]; M(i)&&Vt(r,i,e)} } function ts(e) {const t=e.type,{mixins: n,extends: s}=t,{mixins: r,optionsCache: i,config: {optionMergeStrategies: o}}=e.appContext,l=i.get(t); let u; return l? u=l:!r.length&&!n&&!s? u=t:(u={},r.length&&r.forEach(a => tn(u,a,o,!0)),tn(u,t,o)),K(t)&&i.set(t,u),u} function tn(e,t,n,s=!1) {const {mixins: r,extends: i}=t; i&&tn(e,i,n,!0),r&&r.forEach(o => tn(e,o,n,!0)); for(const o in t) if(!(s&&o==="expose")) {const l=vo[o]||n&&n[o]; e[o]=l? l(e[o],t[o]):t[o]} return e} const vo={data: As,props: Xe,emits: Xe,methods: Xe,computed: Xe,beforeCreate: oe,created: oe,beforeMount: oe,mounted: oe,beforeUpdate: oe,updated: oe,beforeDestroy: oe,beforeUnmount: oe,destroyed: oe,unmounted: oe,activated: oe,deactivated: oe,errorCaptured: oe,serverPrefetch: oe,components: Xe,directives: Xe,watch: Fo,provide: As,inject: Eo}; function As(e,t) {return t? e? function() {return re(M(e)? e.call(this,this):e,M(t)? t.call(this,this):t)}:t:e} function Eo(e,t) {return Xe(Rn(e),Rn(t))} function Rn(e) {if(F(e)) {const t={}; for(let n=0;n<e.length;n++)t[e[n]]=e[n]; return t} return e} function oe(e,t) {return e? [...new Set([].concat(e,t))]:t} function Xe(e,t) {return e? re(re(Object.create(null),e),t):t} function Fo(e,t) {if(!e) return t; if(!t) return e; const n=re(Object.create(null),e); for(const s in t) n[s]=oe(e[s],t[s]); return n} function Ao(e,t,n,s=!1) {const r={},i={}; Yt(i,an,1),e.propsDefaults=Object.create(null),Or(e,t,r,i); for(const o in e.propsOptions[0]) o in r||(r[o]=void 0); n? e.props=s? r:Hi(r):e.type.props? e.props=r:e.props=i,e.attrs=i} function Io(e,t,n,s) {const {props: r,attrs: i,vnode: {patchFlag: o}}=e,l=$(r),[u]=e.propsOptions; let a=!1; if((s||o>0)&&!(o&16)) {if(o&8) {const p=e.vnode.dynamicProps; for(let y=0;y<p.length;y++) {let T=p[y]; if(ln(e.emitsOptions,T)) continue; const A=t[T]; if(u) if(k(i,T)) A!==i[T]&&(i[T]=A,a=!0); else {const N=gt(T); r[N]=kn(u,l,N,A,e,!1)} else A!==i[T]&&(i[T]=A,a=!0)} } } else {Or(e,t,r,i)&&(a=!0); let p; for(const y in l) (!t||!k(t,y)&&((p=ot(y))===y||!k(t,p)))&&(u? n&&(n[y]!==void 0||n[p]!==void 0)&&(r[y]=kn(u,l,y,void 0,e,!0)):delete r[y]); if(i!==l) for(const y in i) (!t||!k(t,y)&&!0)&&(delete i[y],a=!0)} a&&$e(e,"set","$attrs")} function Or(e,t,n,s) {const [r,i]=e.propsOptions; let o=!1,l; if(t) for(let u in t) {if(Kt(u)) continue; const a=t[u]; let p; r&&k(r,p=gt(u))? !i||!i.includes(p)? n[p]=a:(l||(l={}))[p]=a:ln(e.emitsOptions,u)||(!(u in s)||a!==s[u])&&(s[u]=a,o=!0)} if(i) {const u=$(n),a=l||B; for(let p=0;p<i.length;p++) {const y=i[p]; n[y]=kn(r,u,y,a[y],e,!k(a,y))} } return o} function kn(e,t,n,s,r,i) {const o=e[n]; if(o!=null) {const l=k(o,"default"); if(l&&s===void 0) {const u=o.default; if(o.type!==Function&&M(u)) {const {propsDefaults: a}=r; n in a? s=a[n]:(bt(r),s=a[n]=u.call(null,t),st())} else s=u} o[0]&&(i&&!l? s=!1:o[1]&&(s===""||s===ot(n))&&(s=!0))} return s} function Rr(e,t,n=!1) {const s=t.propsCache,r=s.get(e); if(r) return r; const i=e.props,o={},l=[]; let u=!1; if(!M(e)) {const p=y => {u=!0; const [T,A]=Rr(y,t,!0); re(o,T),A&&l.push(...A)}; !n&&t.mixins.length&&t.mixins.forEach(p),e.extends&&p(e.extends),e.mixins&&e.mixins.forEach(p)} if(!i&&!u) return K(e)&&s.set(e,at),at; if(F(i)) for(let p=0;p<i.length;p++) {const y=gt(i[p]); Is(y)&&(o[y]=B)} else if(i) for(const p in i) {const y=gt(p); if(Is(y)) {const T=i[p],A=o[y]=F(T)||M(T)? {type: T}:T; if(A) {const N=Os(Boolean,A.type),P=Os(String,A.type); A[0]=N>-1,A[1]=P<0||N<P,(N>-1||k(A,"default"))&&l.push(y)} } } const a=[o,l]; return K(e)&&s.set(e,a),a} function Is(e) {return e[0]!=="$"} function Ps(e) {const t=e&&e.toString().match(/^\s*function (\w+)/); return t? t[1]:e===null? "null":""} function Ms(e,t) {return Ps(e)===Ps(t)} function Os(e,t) {return F(t)? t.findIndex(n => Ms(n,e)):M(t)&&Ms(t,e)? 0:-1} const kr=e => e[0]==="_"||e==="$stable",ns=e => F(e)? e.map(Pe):[Pe(e)],Po=(e,t,n) => {if(t._n) return t; const s=Xi((...r) => ns(t(...r)),n); return s._c=!1,s},Sr=(e,t,n) => {const s=e._ctx; for(const r in e) {if(kr(r)) continue; const i=e[r]; if(M(i)) t[r]=Po(r,i,s); else if(i!=null) {const o=ns(i); t[r]=() => o} } },Lr=(e,t) => {const n=ns(t); e.slots.default=() => n},Mo=(e,t) => {if(e.vnode.shapeFlag&32) {const n=t._; n? (e.slots=$(t),Yt(t,"_",n)):Sr(t,e.slots={})} else e.slots={},t&&Lr(e,t); Yt(e.slots,an,1)},Oo=(e,t,n) => {const {vnode: s,slots: r}=e; let i=!0,o=B; if(s.shapeFlag&32) {const l=t._; l? n&&l===1? i=!1:(re(r,t),!n&&l===1&&delete r._):(i=!t.$stable,Sr(t,r)),o=t} else t&&(Lr(e,t),o={default: 1}); if(i) for(const l in r) !kr(l)&&!(l in o)&&delete r[l]}; function $r() {return {app: null,config: {isNativeTag: ri,performance: !1,globalProperties: {},optionMergeStrategies: {},errorHandler: void 0,warnHandler: void 0,compilerOptions: {}},mixins: [],components: {},directives: {},provides: Object.create(null),optionsCache: new WeakMap,propsCache: new WeakMap,emitsCache: new WeakMap}} let Ro=0; function ko(e,t) {return function(s,r=null) {M(s)||(s=Object.assign({},s)),r!=null&&!K(r)&&(r=null); const i=$r(),o=new Set; let l=!1; const u=i.app={_uid: Ro++,_component: s,_props: r,_container: null,_context: i,_instance: null,version: Zo,get config() {return i.config},set config(a) {},use(a,...p) {return o.has(a)||(a&&M(a.install)? (o.add(a),a.install(u,...p)):M(a)&&(o.add(a),a(u,...p))),u},mixin(a) {return i.mixins.includes(a)||i.mixins.push(a),u},component(a,p) {return p? (i.components[a]=p,u):i.components[a]},directive(a,p) {return p? (i.directives[a]=p,u):i.directives[a]},mount(a,p,y) {if(!l) {const T=Ce(s,r); return T.appContext=i,p&&t? t(T,a):e(T,a,y),l=!0,u._container=a,a.__vue_app__=u,dn(T.component)||T.component.proxy} },unmount() {l&&(e(null,u._container),delete u._container.__vue_app__)},provide(a,p) {return i.provides[a]=p,u} }; return u}} function Sn(e,t,n,s,r=!1) {if(F(e)) {e.forEach((T,A) => Sn(T,t&&(F(t)? t[A]:t),n,s,r)); return } if(qt(s)&&!r) return; const i=s.shapeFlag&4? dn(s.component)||s.component.proxy:s.el,o=r? null:i,{i: l,r: u}=e,a=t&&t.r,p=l.refs===B? l.refs={}:l.refs,y=l.setupState; if(a!=null&&a!==u&&(te(a)? (p[a]=null,k(y,a)&&(y[a]=null)):ee(a)&&(a.value=null)),M(u)) De(u,l,12,[o,p]); else {const T=te(u),A=ee(u); if(T||A) {const N=() => {if(e.f) {const P=T? k(y,u)? y[u]:p[u]:u.value; r? F(P)&&Dn(P,i):F(P)? P.includes(i)||P.push(i):T? (p[u]=[i],k(y,u)&&(y[u]=p[u])):(u.value=[i],e.k&&(p[e.k]=u.value))} else T? (p[u]=o,k(y,u)&&(y[u]=o)):A&&(u.value=o,e.k&&(p[e.k]=o))}; o? (N.id=-1,ce(N,n)):N()} } } const ce=so; function So(e) {return Lo(e)} function Lo(e,t) {const n=fi(); n.__VUE__=!0; const {insert: s,remove: r,patchProp: i,createElement: o,createText: l,createComment: u,setText: a,setElementText: p,parentNode: y,nextSibling: T,setScopeId: A=we,insertStaticContent: N}=e,P=(c,f,d,g=null,h=null,_=null,w=!1,b=null,x=!!f.dynamicChildren) => {if(c===f) return; c&&!Ge(c,f)&&(g=$t(c),Ee(c,h,_,!0),c=null),f.patchFlag===-2&&(x=!1,f.dynamicChildren=null); const {type: m,ref: v,shapeFlag: C}=f; switch(m) {case ss: U(c,f,d,g); break; case Te: S(c,f,d,g); break; case xn: c==null&&me(f,d,g,w); break; case G: ve(c,f,d,g,h,_,w,b,x); break; default: C&1? le(c,f,d,g,h,_,w,b,x):C&6? Oe(c,f,d,g,h,_,w,b,x):(C&64||C&128)&&m.process(c,f,d,g,h,_,w,b,x,ct)}v!=null&&h&&Sn(v,c&&c.ref,_,f||c,!f)},U=(c,f,d,g) => {if(c==null) s(f.el=l(f.children),d,g); else {const h=f.el=c.el; f.children!==c.children&&a(h,f.children)} },S=(c,f,d,g) => {c==null? s(f.el=u(f.children||""),d,g):f.el=c.el},me=(c,f,d,g) => {[c.el,c.anchor]=N(c.children,f,d,g,c.el,c.anchor)},X=({el: c,anchor: f},d,g) => {let h; for(;c&&c!==f;)h=T(c),s(c,d,g),c=h; s(f,d,g)},z=({el: c,anchor: f}) => {let d; for(;c&&c!==f;)d=T(c),r(c),c=d; r(f)},le=(c,f,d,g,h,_,w,b,x) => {w=w||f.type==="svg",c==null? lt(f,d,g,h,_,w,b,x):Z(c,f,h,_,w,b,x)},lt=(c,f,d,g,h,_,w,b) => {let x,m; const {type: v,props: C,shapeFlag: E,transition: I,dirs: R}=c; if(x=c.el=o(c.type,_,C&&C.is,C),E&8? p(x,c.children):E&16&&O(c.children,x,null,g,h,_&&v!=="foreignObject",w,b),R&&Je(c,null,g,"created"),C) {for(const H in C) H!=="value"&&!Kt(H)&&i(x,H,null,C[H],_,c.children,g,h,Re); "value" in C&&i(x,"value",null,C.value),(m=C.onVnodeBeforeMount)&&Ae(m,g,c)} He(x,c,c.scopeId,w,g),R&&Je(c,null,g,"beforeMount"); const D=(!h||h&&!h.pendingBranch)&&I&&!I.persisted; D&&I.beforeEnter(x),s(x,f,d),((m=C&&C.onVnodeMounted)||D||R)&&ce(() => {m&&Ae(m,g,c),D&&I.enter(x),R&&Je(c,null,g,"mounted")},h)},He=(c,f,d,g,h) => {if(d&&A(c,d),g) for(let _=0;_<g.length;_++)A(c,g[_]); if(h) {let _=h.subTree; if(f===_) {const w=h.vnode; He(c,w,w.scopeId,w.slotScopeIds,h.parent)} } },O=(c,f,d,g,h,_,w,b,x=0) => {for(let m=x;m<c.length;m++) {const v=c[m]=b? Ue(c[m]):Pe(c[m]); P(null,v,f,d,g,h,_,w,b)} },Z=(c,f,d,g,h,_,w) => {const b=f.el=c.el; let {patchFlag: x,dynamicChildren: m,dirs: v}=f; x|=c.patchFlag&16; const C=c.props||B,E=f.props||B; let I; d&&Ye(d,!1),(I=E.onVnodeBeforeUpdate)&&Ae(I,d,f,c),v&&Je(f,c,d,"beforeUpdate"),d&&Ye(d,!0); const R=h&&f.type!=="foreignObject"; if(m? Q(c.dynamicChildren,m,b,d,g,R,_):w||j(c,f,b,null,d,g,R,_,!1),x>0) {if(x&16) fe(b,f,C,E,d,g,h); else if(x&2&&C.class!==E.class&&i(b,"class",null,E.class,h),x&4&&i(b,"style",C.style,E.style,h),x&8) {const D=f.dynamicProps; for(let H=0;H<D.length;H++) {const J=D[H],be=C[J],ut=E[J]; (ut!==be||J==="value")&&i(b,J,be,ut,h,c.children,d,g,Re)} } x&1&&c.children!==f.children&&p(b,f.children)} else !w&&m==null&&fe(b,f,C,E,d,g,h); ((I=E.onVnodeUpdated)||v)&&ce(() => {I&&Ae(I,d,f,c),v&&Je(f,c,d,"updated")},g)},Q=(c,f,d,g,h,_,w) => {for(let b=0;b<f.length;b++) {const x=c[b],m=f[b],v=x.el&&(x.type===G||!Ge(x,m)||x.shapeFlag&70)? y(x.el):d; P(x,m,v,null,g,h,_,w,!0)} },fe=(c,f,d,g,h,_,w) => {if(d!==g) {if(d!==B) for(const b in d) !Kt(b)&&!(b in g)&&i(c,b,d[b],null,w,f.children,h,_,Re); for(const b in g) {if(Kt(b)) continue; const x=g[b],m=d[b]; x!==m&&b!=="value"&&i(c,b,m,x,w,f.children,h,_,Re)} "value" in g&&i(c,"value",d.value,g.value)} },ve=(c,f,d,g,h,_,w,b,x) => {const m=f.el=c? c.el:l(""),v=f.anchor=c? c.anchor:l(""); let {patchFlag: C,dynamicChildren: E,slotScopeIds: I}=f; I&&(b=b? b.concat(I):I),c==null? (s(m,d,g),s(v,d,g),O(f.children,d,v,h,_,w,b,x)):C>0&&C&64&&E&&c.dynamicChildren? (Q(c.dynamicChildren,E,d,h,_,w,b),(f.key!=null||h&&f===h.subTree)&&Nr(c,f,!0)):j(c,f,d,v,h,_,w,b,x)},Oe=(c,f,d,g,h,_,w,b,x) => {f.slotScopeIds=b,c==null? f.shapeFlag&512? h.ctx.activate(f,d,g,w,x):Tt(f,d,g,h,_,w,x):ls(c,f,x)},Tt=(c,f,d,g,h,_,w) => {const b=c.component=Wo(c,g,h); if(un(c)&&(b.ctx.renderer=ct),qo(b),b.asyncDep) {if(h&&h.registerDep(b,ie),!c.el) {const x=b.subTree=Ce(Te); S(null,x,f,d)} return } ie(b,c,f,d,h,_,w)},ls=(c,f,d) => {const g=f.component=c.component; if(eo(c,f,d)) if(g.asyncDep&&!g.asyncResolved) {W(g,f,d); return } else g.next=f,qi(g.update),g.update(); else f.el=c.el,g.vnode=f},ie=(c,f,d,g,h,_,w) => {const b=() => {if(c.isMounted) {let {next: v,bu: C,u: E,parent: I,vnode: R}=c,D=v,H; Ye(c,!1),v? (v.el=R.el,W(c,v,w)):v=R,C&&Qt(C),(H=v.props&&v.props.onVnodeBeforeUpdate)&&Ae(H,I,v,R),Ye(c,!0); const J=bn(c),be=c.subTree; c.subTree=J,P(be,J,y(be.el),$t(be),c,h,_),v.el=J.el,D===null&&to(c,J.el),E&&ce(E,h),(H=v.props&&v.props.onVnodeUpdated)&&ce(() => Ae(H,I,v,R),h)} else {let v; const {el: C,props: E}=f,{bm: I,m: R,parent: D}=c,H=qt(f); if(Ye(c,!1),I&&Qt(I),!H&&(v=E&&E.onVnodeBeforeMount)&&Ae(v,D,f),Ye(c,!0),C&&gn) {const J=() => {c.subTree=bn(c),gn(C,c.subTree,c,h,null)}; H? f.type.__asyncLoader().then(() => !c.isUnmounted&&J()):J()} else {const J=c.subTree=bn(c); P(null,J,d,g,c,h,_),f.el=J.el} if(R&&ce(R,h),!H&&(v=E&&E.onVnodeMounted)) {const J=f; ce(() => Ae(v,D,J),h)} (f.shapeFlag&256||D&&qt(D.vnode)&&D.vnode.shapeFlag&256)&&c.a&&ce(c.a,h),c.isMounted=!0,f=d=g=null} },x=c.effect=new Wn(b,() => Gn(m),c.scope),m=c.update=() => x.run(); m.id=c.uid,Ye(c,!0),m()},W=(c,f,d) => {f.component=c; const g=c.vnode.props; c.vnode=f,c.next=null,Io(c,f.props,g,d),Oo(c,f.children,d),xt(),Ts(),wt()},j=(c,f,d,g,h,_,w,b,x=!1) => {const m=c&&c.children,v=c? c.shapeFlag:0,C=f.children,{patchFlag: E,shapeFlag: I}=f; if(E>0) {if(E&128) {Lt(m,C,d,g,h,_,w,b,x); return } else if(E&256) {qe(m,C,d,g,h,_,w,b,x); return } } I&8? (v&16&&Re(m,h,_),C!==m&&p(d,C)):v&16? I&16? Lt(m,C,d,g,h,_,w,b,x):Re(m,h,_,!0):(v&8&&p(d,""),I&16&&O(C,d,g,h,_,w,b,x))},qe=(c,f,d,g,h,_,w,b,x) => {c=c||at,f=f||at; const m=c.length,v=f.length,C=Math.min(m,v); let E; for(E=0;E<C;E++) {const I=f[E]=x? Ue(f[E]):Pe(f[E]); P(c[E],I,d,null,h,_,w,b,x)} m>v? Re(c,h,_,!0,!1,C):O(f,d,g,h,_,w,b,x,C)},Lt=(c,f,d,g,h,_,w,b,x) => {let m=0; const v=f.length; let C=c.length-1,E=v-1; for(;m<=C&&m<=E;) {const I=c[m],R=f[m]=x? Ue(f[m]):Pe(f[m]); if(Ge(I,R)) P(I,R,d,null,h,_,w,b,x); else break; m++} for(;m<=C&&m<=E;) {const I=c[C],R=f[E]=x? Ue(f[E]):Pe(f[E]); if(Ge(I,R)) P(I,R,d,null,h,_,w,b,x); else break; C--,E--} if(m>C) {if(m<=E) {const I=E+1,R=I<v? f[I].el:g; for(;m<=E;)P(null,f[m]=x? Ue(f[m]):Pe(f[m]),d,R,h,_,w,b,x),m++} } else if(m>E) for(;m<=C;)Ee(c[m],h,_,!0),m++; else {const I=m,R=m,D=new Map; for(m=R;m<=E;m++) {const ae=f[m]=x? Ue(f[m]):Pe(f[m]); ae.key!=null&&D.set(ae.key,m)} let H,J=0; const be=E-R+1; let ut=!1,fs=0; const Ct=new Array(be); for(m=0;m<be;m++)Ct[m]=0; for(m=I;m<=C;m++) {const ae=c[m]; if(J>=be) {Ee(ae,h,_,!0); continue} let Fe; if(ae.key!=null) Fe=D.get(ae.key); else for(H=R;H<=E;H++)if(Ct[H-R]===0&&Ge(ae,f[H])) {Fe=H; break} Fe===void 0? Ee(ae,h,_,!0):(Ct[Fe-R]=m+1,Fe>=fs? fs=Fe:ut=!0,P(ae,f[Fe],d,null,h,_,w,b,x),J++)} const as=ut? $o(Ct):at; for(H=as.length-1,m=be-1;m>=0;m--) {const ae=R+m,Fe=f[ae],ds=ae+1<v? f[ae+1].el:g; Ct[m]===0? P(null,Fe,d,ds,h,_,w,b,x):ut&&(H<0||m!==as[H]? ze(Fe,d,ds,2):H--)} } },ze=(c,f,d,g,h=null) => {const {el: _,type: w,transition: b,children: x,shapeFlag: m}=c; if(m&6) {ze(c.component.subTree,f,d,g); return } if(m&128) {c.suspense.move(f,d,g); return } if(m&64) {w.move(c,f,d,ct); return } if(w===G) {s(_,f,d); for(let C=0;C<x.length;C++)ze(x[C],f,d,g); s(c.anchor,f,d); return } if(w===xn) {X(c,f,d); return } if(g!==2&&m&1&&b) if(g===0) b.beforeEnter(_),s(_,f,d),ce(() => b.enter(_),h); else {const {leave: C,delayLeave: E,afterLeave: I}=b,R=() => s(_,f,d),D=() => {C(_,() => {R(),I&&I()})}; E? E(_,R,D):D()} else s(_,f,d)},Ee=(c,f,d,g=!1,h=!1) => {const {type: _,props: w,ref: b,children: x,dynamicChildren: m,shapeFlag: v,patchFlag: C,dirs: E}=c; if(b!=null&&Sn(b,null,d,c,!0),v&256) {f.ctx.deactivate(c); return } const I=v&1&&E,R=!qt(c); let D; if(R&&(D=w&&w.onVnodeBeforeUnmount)&&Ae(D,f,c),v&6) Jr(c.component,d,g); else {if(v&128) {c.suspense.unmount(d,g); return } I&&Je(c,null,f,"beforeUnmount"),v&64? c.type.remove(c,f,d,h,ct,g):m&&(_!==G||C>0&&C&64)? Re(m,f,d,!1,!0):(_===G&&C&384||!h&&v&16)&&Re(x,f,d),g&&cs(c)} (R&&(D=w&&w.onVnodeUnmounted)||I)&&ce(() => {D&&Ae(D,f,c),I&&Je(c,null,f,"unmounted")},d)},cs=c => {const {type: f,el: d,anchor: g,transition: h}=c; if(f===G) {zr(d,g); return } if(f===xn) {z(c); return } const _=() => {r(d),h&&!h.persisted&&h.afterLeave&&h.afterLeave()}; if(c.shapeFlag&1&&h&&!h.persisted) {const {leave: w,delayLeave: b}=h,x=() => w(d,_); b? b(c.el,_,x):x()} else _()},zr=(c,f) => {let d; for(;c!==f;)d=T(c),r(c),c=d; r(f)},Jr=(c,f,d) => {const {bum: g,scope: h,update: _,subTree: w,um: b}=c; g&&Qt(g),h.stop(),_&&(_.active=!1,Ee(w,c,f,d)),b&&ce(b,f),ce(() => {c.isUnmounted=!0},f),f&&f.pendingBranch&&!f.isUnmounted&&c.asyncDep&&!c.asyncResolved&&c.suspenseId===f.pendingId&&(f.deps--,f.deps===0&&f.resolve())},Re=(c,f,d,g=!1,h=!1,_=0) => {for(let w=_;w<c.length;w++)Ee(c[w],f,d,g,h)},$t=c => c.shapeFlag&6? $t(c.component.subTree):c.shapeFlag&128? c.suspense.next():T(c.anchor||c.el),us=(c,f,d) => {c==null? f._vnode&&Ee(f._vnode,null,null,!0):P(f._vnode||null,c,f,null,null,null,d),Ts(),_r(),f._vnode=c},ct={p: P,um: Ee,m: ze,r: cs,mt: Tt,mc: O,pc: j,pbc: Q,n: $t,o: e}; let pn,gn; return t&&([pn,gn]=t(ct)),{render: us,hydrate: pn,createApp: ko(us,pn)}} function Ye({effect: e,update: t},n) {e.allowRecurse=t.allowRecurse=n} function Nr(e,t,n=!1) {const s=e.children,r=t.children; if(F(s)&&F(r)) for(let i=0;i<s.length;i++) {const o=s[i]; let l=r[i]; l.shapeFlag&1&&!l.dynamicChildren&&((l.patchFlag<=0||l.patchFlag===32)&&(l=r[i]=Ue(r[i]),l.el=o.el),n||Nr(o,l))} } function $o(e) {const t=e.slice(),n=[0]; let s,r,i,o,l; const u=e.length; for(s=0;s<u;s++) {const a=e[s]; if(a!==0) {if(r=n[n.length-1],e[r]<a) {t[s]=r,n.push(s); continue} for(i=0,o=n.length-1;i<o;)l=i+o>>1,e[n[l]]<a? i=l+1:o=l; a<e[n[i]]&&(i>0&&(t[s]=n[i-1]),n[i]=s)} } for(i=n.length,o=n[i-1];i-->0;)n[i]=o,o=t[o]; return n} const No=e => e.__isTeleport,G=Symbol(void 0),ss=Symbol(void 0),Te=Symbol(void 0),xn=Symbol(void 0),Et=[]; let xe=null; function V(e=!1) {Et.push(xe=e? null:[])} function Ho() {Et.pop(),xe=Et[Et.length-1]||null} let Rt=1; function Rs(e) {Rt+=e} function Hr(e) {return e.dynamicChildren=Rt>0? xe||at:null,Ho(),Rt>0&&xe&&xe.push(e),e} function Y(e,t,n,s,r,i) {return Hr(L(e,t,n,s,r,i,!0))} function Br(e,t,n,s,r) {return Hr(Ce(e,t,n,s,r,!0))} function Bo(e) {return e? e.__v_isVNode===!0:!1} function Ge(e,t) {return e.type===t.type&&e.key===t.key} const an="__vInternal",Ur=({key: e}) => e!=null? e:null,zt=({ref: e,ref_key: t,ref_for: n}) => e!=null? te(e)||ee(e)||M(e)? {i: ye,r: e,k: t,f: !!n}:e:null; function L(e,t=null,n=null,s=0,r=null,i=e===G? 0:1,o=!1,l=!1) {const u={__v_isVNode: !0,__v_skip: !0,type: e,props: t,key: t&&Ur(t),ref: t&&zt(t),scopeId: wr,slotScopeIds: null,children: n,component: null,suspense: null,ssContent: null,ssFallback: null,dirs: null,transition: null,el: null,anchor: null,target: null,targetAnchor: null,staticCount: 0,shapeFlag: i,patchFlag: s,dynamicProps: r,dynamicChildren: null,appContext: null}; return l? (rs(u,n),i&128&&e.normalize(u)):n&&(u.shapeFlag|=te(n)? 8:16),Rt>0&&!o&&xe&&(u.patchFlag>0||i&6)&&u.patchFlag!==32&&xe.push(u),u} const Ce=Uo; function Uo(e,t=null,n=null,s=0,r=null,i=!1) {if((!e||e===xo)&&(e=Te),Bo(e)) {const l=We(e,t,!0); return n&&rs(l,n),Rt>0&&!i&&xe&&(l.shapeFlag&6? xe[xe.indexOf(e)]=l:xe.push(l)),l.patchFlag|=-2,l} if(Xo(e)&&(e=e.__vccOpts),t) {t=jo(t); let {class: l,style: u}=t; l&&!te(l)&&(t.class=Bn(l)),K(u)&&(fr(u)&&!F(u)&&(u=re({},u)),t.style=rt(u))} const o=te(e)? 1:no(e)? 128:No(e)? 64:K(e)? 4:M(e)? 2:0; return L(e,t,n,s,r,o,i,!0)} function jo(e) {return e? fr(e)||an in e? re({},e):e:null} function We(e,t,n=!1) {const {props: s,ref: r,patchFlag: i,children: o}=e,l=t? Do(s||{},t):s; return {__v_isVNode: !0,__v_skip: !0,type: e.type,props: l,key: l&&Ur(l),ref: t&&t.ref? n&&r? F(r)? r.concat(zt(t)):[r,zt(t)]:zt(t):r,scopeId: e.scopeId,slotScopeIds: e.slotScopeIds,children: o,target: e.target,targetAnchor: e.targetAnchor,staticCount: e.staticCount,shapeFlag: e.shapeFlag,patchFlag: t&&e.type!==G? i===-1? 16:i|16:i,dynamicProps: e.dynamicProps,dynamicChildren: e.dynamicChildren,appContext: e.appContext,dirs: e.dirs,transition: e.transition,component: e.component,suspense: e.suspense,ssContent: e.ssContent&&We(e.ssContent),ssFallback: e.ssFallback&&We(e.ssFallback),el: e.el,anchor: e.anchor}} function jr(e=" ",t=0) {return Ce(ss,null,e,t)} function ks(e="",t=!1) {return t? (V(),Br(Te,null,e)):Ce(Te,null,e)} function Pe(e) {return e==null||typeof e=="boolean"? Ce(Te):F(e)? Ce(G,null,e.slice()):typeof e=="object"? Ue(e):Ce(ss,null,String(e))} function Ue(e) {return e.el===null&&e.patchFlag!==-1||e.memo? e:We(e)} function rs(e,t) {let n=0; const {shapeFlag: s}=e; if(t==null) t=null; else if(F(t)) n=16; else if(typeof t=="object") if(s&65) {const r=t.default; r&&(r._c&&(r._d=!1),rs(e,r()),r._c&&(r._d=!0)); return } else {n=32; const r=t._; !r&&!(an in t)? t._ctx=ye:r===3&&ye&&(ye.slots._===1? t._=1:(t._=2,e.patchFlag|=1024))} else M(t)? (t={default: t,_ctx: ye},n=32):(t=String(t),s&64? (n=16,t=[jr(t)]):n=8); e.children=t,e.shapeFlag|=n} function Do(...e) {const t={}; for(let n=0;n<e.length;n++) {const s=e[n]; for(const r in s) if(r==="class") t.class!==s.class&&(t.class=Bn([t.class,s.class])); else if(r==="style") t.style=rt([t.style,s.style]); else if(nn(r)) {const i=t[r],o=s[r]; o&&i!==o&&!(F(i)&&i.includes(o))&&(t[r]=i? [].concat(i,o):o)} else r!==""&&(t[r]=s[r])} return t} function Ae(e,t,n,s=null) {ge(e,t,7,[n,s])} const Ko=$r(); let Qo=0; function Wo(e,t,n) {const s=e.type,r=(t? t.appContext:e.appContext)||Ko,i={uid: Qo++,vnode: e,type: s,parent: t,appContext: r,root: null,next: null,subTree: null,effect: null,update: null,scope: new ai(!0),render: null,proxy: null,exposed: null,exposeProxy: null,withProxy: null,provides: t? t.provides:Object.create(r.provides),accessCache: null,renderCache: [],components: null,directives: null,propsOptions: Rr(s,r),emitsOptions: xr(s,r),emit: null,emitted: null,propsDefaults: B,inheritAttrs: s.inheritAttrs,ctx: B,data: B,props: B,attrs: B,slots: B,refs: B,setupState: B,setupContext: null,suspense: n,suspenseId: n? n.pendingId:0,asyncDep: null,asyncResolved: !1,isMounted: !1,isUnmounted: !1,isDeactivated: !1,bc: null,c: null,bm: null,m: null,bu: null,u: null,um: null,bum: null,da: null,a: null,rtg: null,rtc: null,ec: null,sp: null}; return i.ctx={_: i},i.root=t? t.root:i,i.emit=Yi.bind(null,i),e.ce&&e.ce(i),i} let ne=null; const Vo=() => ne||ye,bt=e => {ne=e,e.scope.on()},st=() => {ne&&ne.scope.off(),ne=null}; function Dr(e) {return e.vnode.shapeFlag&4} let kt=!1; function qo(e,t=!1) {kt=t; const {props: n,children: s}=e.vnode,r=Dr(e); Ao(e,n,r,t),Mo(e,s); const i=r? zo(e,t):void 0; return kt=!1,i} function zo(e,t) {const n=e.type; e.accessCache=Object.create(null),e.proxy=ar(new Proxy(e.ctx,wo)); const {setup: s}=n; if(s) {const r=e.setupContext=s.length>1? Yo(e):null; bt(e),xt(); const i=De(s,e,0,[e.props,r]); if(wt(),st(),Js(i)) {if(i.then(st,st),t) return i.then(o => {Ss(e,o,t)}).catch(o => {on(o,e,0)}); e.asyncDep=i} else Ss(e,i,t)} else Kr(e,t)} function Ss(e,t,n) {M(t)? e.type.__ssrInlineRender? e.ssrRender=t:e.render=t:K(t)&&(e.setupState=pr(t)),Kr(e,n)} let Ls; function Kr(e,t,n) {const s=e.type; if(!e.render) {if(!t&&Ls&&!s.render) {const r=s.template||ts(e).template; if(r) {const {isCustomElement: i,compilerOptions: o}=e.appContext.config,{delimiters: l,compilerOptions: u}=s,a=re(re({isCustomElement: i,delimiters: l},o),u); s.render=Ls(r,a)} } e.render=s.render||we} bt(e),xt(),To(e),wt(),st()} function Jo(e) {return new Proxy(e.attrs,{get(t,n) {return he(e,"get","$attrs"),t[n]} })} function Yo(e) {const t=s => {e.exposed=s||{}}; let n; return {get attrs() {return n||(n=Jo(e))},slots: e.slots,emit: e.emit,expose: t}} function dn(e) {if(e.exposed) return e.exposeProxy||(e.exposeProxy=new Proxy(pr(ar(e.exposed)),{get(t,n) {if(n in t) return t[n]; if(n in en) return en[n](e)} }))} function Xo(e) {return M(e)&&"__vccOpts" in e} const Ft=(e,t) => Ki(e,t,kt),Zo="3.2.41",Go="http://www.w3.org/2000/svg",et=typeof document<"u"? document:null,$s=et&&et.createElement("template"),el={insert: (e,t,n) => {t.insertBefore(e,n||null)},remove: e => {const t=e.parentNode; t&&t.removeChild(e)},createElement: (e,t,n,s) => {const r=t? et.createElementNS(Go,e):et.createElement(e,n? {is: n}:void 0); return e==="select"&&s&&s.multiple!=null&&r.setAttribute("multiple",s.multiple),r},createText: e => et.createTextNode(e),createComment: e => et.createComment(e),setText: (e,t) => {e.nodeValue=t},setElementText: (e,t) => {e.textContent=t},parentNode: e => e.parentNode,nextSibling: e => e.nextSibling,querySelector: e => et.querySelector(e),setScopeId(e,t) {e.setAttribute(t,"")},insertStaticContent(e,t,n,s,r,i) {const o=n? n.previousSibling:t.lastChild; if(r&&(r===i||r.nextSibling)) for(;t.insertBefore(r.cloneNode(!0),n),!(r===i||!(r=r.nextSibling));); else {$s.innerHTML=s? `<svg>${e}</svg>`:e; const l=$s.content; if(s) {const u=l.firstChild; for(;u.firstChild;)l.appendChild(u.firstChild); l.removeChild(u)} t.insertBefore(l,n)} return [o? o.nextSibling:t.firstChild,n? n.previousSibling:t.lastChild]} }; function tl(e,t,n) {const s=e._vtc; s&&(t=(t? [t,...s]:[...s]).join(" ")),t==null? e.removeAttribute("class"):n? e.setAttribute("class",t):e.className=t} function nl(e,t,n) {const s=e.style,r=te(n); if(n&&!r) {for(const i in n) Ln(s,i,n[i]); if(t&&!te(t)) for(const i in t) n[i]==null&&Ln(s,i,"")} else {const i=s.display; r? t!==n&&(s.cssText=n):t&&e.removeAttribute("style"),"_vod" in e&&(s.display=i)} } const Ns=/\s*!important$/; function Ln(e,t,n) {if(F(n)) n.forEach(s => Ln(e,t,s)); else if(n==null&&(n=""),t.startsWith("--")) e.setProperty(t,n); else {const s=sl(e,t); Ns.test(n)? e.setProperty(ot(s),n.replace(Ns,""),"important"):e[s]=n} } const Hs=["Webkit","Moz","ms"],wn={}; function sl(e,t) {const n=wn[t]; if(n) return n; let s=gt(t); if(s!=="filter"&&s in e) return wn[t]=s; s=Zs(s); for(let r=0;r<Hs.length;r++) {const i=Hs[r]+s; if(i in e) return wn[t]=i} return t} const Bs="http://www.w3.org/1999/xlink"; function rl(e,t,n,s,r) {if(s&&t.startsWith("xlink:")) n==null? e.removeAttributeNS(Bs,t.slice(6,t.length)):e.setAttributeNS(Bs,t,n); else {const i=Gr(t); n==null||i&&!qs(n)? e.removeAttribute(t):e.setAttribute(t,i? "":n)} } function il(e,t,n,s,r,i,o) {if(t==="innerHTML"||t==="textContent") {s&&o(s,r,i),e[t]=n==null? "":n; return } if(t==="value"&&e.tagName!=="PROGRESS"&&!e.tagName.includes("-")) {e._value=n; const u=n==null? "":n; (e.value!==u||e.tagName==="OPTION")&&(e.value=u),n==null&&e.removeAttribute(t); return } let l=!1; if(n===""||n==null) {const u=typeof e[t]; u==="boolean"? n=qs(n):n==null&&u==="string"? (n="",l=!0):u==="number"&&(n=0,l=!0)} try {e[t]=n} catch {} l&&e.removeAttribute(t)} function Le(e,t,n,s) {e.addEventListener(t,n,s)} function ol(e,t,n,s) {e.removeEventListener(t,n,s)} function ll(e,t,n,s,r=null) {const i=e._vei||(e._vei={}),o=i[t]; if(s&&o) o.value=s; else {const [l,u]=cl(t); if(s) {const a=i[t]=al(s,r); Le(e,l,a,u)} else o&&(ol(e,l,o,u),i[t]=void 0)} } const Us=/(?:Once|Passive|Capture)$/; function cl(e) {let t; if(Us.test(e)) {t={}; let s; for(;s=e.match(Us);)e=e.slice(0,e.length-s[0].length),t[s[0].toLowerCase()]=!0} return [e[2]===":"? e.slice(3):ot(e.slice(2)),t]} let Tn=0; const ul=Promise.resolve(),fl=() => Tn||(ul.then(() => Tn=0),Tn=Date.now()); function al(e,t) {const n=s => {if(!s._vts) s._vts=Date.now(); else if(s._vts<=n.attached) return; ge(dl(s,n.value),t,5,[s])}; return n.value=e,n.attached=fl(),n} function dl(e,t) {if(F(t)) {const n=e.stopImmediatePropagation; return e.stopImmediatePropagation=() => {n.call(e),e._stopped=!0},t.map(s => r => !r._stopped&&s&&s(r))} else return t} const js=/^on[a-z]/,hl=(e,t,n,s,r=!1,i,o,l,u) => {t==="class"? tl(e,s,r):t==="style"? nl(e,n,s):nn(t)? jn(t)||ll(e,t,n,s,o):(t[0]==="."? (t=t.slice(1),!0):t[0]==="^"? (t=t.slice(1),!1):pl(e,t,s,r))? il(e,t,s,i,o,l,u):(t==="true-value"? e._trueValue=s:t==="false-value"&&(e._falseValue=s),rl(e,t,s,r))}; function pl(e,t,n,s) {return s? !!(t==="innerHTML"||t==="textContent"||t in e&&js.test(t)&&M(n)):t==="spellcheck"||t==="draggable"||t==="translate"||t==="form"||t==="list"&&e.tagName==="INPUT"||t==="type"&&e.tagName==="TEXTAREA"||js.test(t)&&te(n)? !1:t in e} const gl={name: String,type: String,css: {type: Boolean,default: !0},duration: [String,Number,Object],enterFromClass: String,enterActiveClass: String,enterToClass: String,appearFromClass: String,appearActiveClass: String,appearToClass: String,leaveFromClass: String,leaveActiveClass: String,leaveToClass: String}; co.props; const Ve=e => {const t=e.props["onUpdate:modelValue"]||!1; return F(t)? n => Qt(t,n):t}; function ml(e) {e.target.composing=!0} function Ds(e) {const t=e.target; t.composing&&(t.composing=!1,t.dispatchEvent(new Event("input")))} const $n={created(e,{modifiers: {lazy: t,trim: n,number: s}},r) {e._assign=Ve(r); const i=s||r.props&&r.props.type==="number"; Le(e,t? "change":"input",o => {if(o.target.composing) return; let l=e.value; n&&(l=l.trim()),i&&(l=Xt(l)),e._assign(l)}),n&&Le(e,"change",() => {e.value=e.value.trim()}),t||(Le(e,"compositionstart",ml),Le(e,"compositionend",Ds),Le(e,"change",Ds))},mounted(e,{value: t}) {e.value=t==null? "":t},beforeUpdate(e,{value: t,modifiers: {lazy: n,trim: s,number: r}},i) {if(e._assign=Ve(i),e.composing||document.activeElement===e&&e.type!=="range"&&(n||s&&e.value.trim()===t||(r||e.type==="number")&&Xt(e.value)===t)) return; const o=t==null? "":t; e.value!==o&&(e.value=o)} },bl={deep: !0,created(e,t,n) {e._assign=Ve(n),Le(e,"change",() => {const s=e._modelValue,r=_t(e),i=e.checked,o=e._assign; if(F(s)) {const l=Un(s,r),u=l!==-1; if(i&&!u) o(s.concat(r)); else if(!i&&u) {const a=[...s]; a.splice(l,1),o(a)} } else if(yt(s)) {const l=new Set(s); i? l.add(r):l.delete(r),o(l)} else o(Wr(e,i))})},mounted: Ks,beforeUpdate(e,t,n) {e._assign=Ve(n),Ks(e,t,n)} }; function Ks(e,{value: t,oldValue: n},s) {e._modelValue=t,F(t)? e.checked=Un(t,s.props.value)>-1:yt(t)? e.checked=t.has(s.props.value):t!==n&&(e.checked=it(t,Wr(e,!0)))} const _l={created(e,{value: t},n) {e.checked=it(t,n.props.value),e._assign=Ve(n),Le(e,"change",() => {e._assign(_t(e))})},beforeUpdate(e,{value: t,oldValue: n},s) {e._assign=Ve(s),t!==n&&(e.checked=it(t,s.props.value))} },Qr={deep: !0,created(e,{value: t,modifiers: {number: n}},s) {const r=yt(t); Le(e,"change",() => {const i=Array.prototype.filter.call(e.options,o => o.selected).map(o => n? Xt(_t(o)):_t(o)); e._assign(e.multiple? r? new Set(i):i:i[0])}),e._assign=Ve(s)},mounted(e,{value: t}) {Qs(e,t)},beforeUpdate(e,t,n) {e._assign=Ve(n)},updated(e,{value: t}) {Qs(e,t)} }; function Qs(e,t) {const n=e.multiple; if(!(n&&!F(t)&&!yt(t))) {for(let s=0,r=e.options.length;s<r;s++) {const i=e.options[s],o=_t(i); if(n) F(t)? i.selected=Un(t,o)>-1:i.selected=t.has(o); else if(it(_t(i),t)) {e.selectedIndex!==s&&(e.selectedIndex=s); return } } !n&&e.selectedIndex!==-1&&(e.selectedIndex=-1)} } function _t(e) {return "_value" in e? e._value:e.value} function Wr(e,t) {const n=t? "_trueValue":"_falseValue"; return n in e? e[n]:t} const yl={created(e,t,n) {Dt(e,t,n,null,"created")},mounted(e,t,n) {Dt(e,t,n,null,"mounted")},beforeUpdate(e,t,n,s) {Dt(e,t,n,s,"beforeUpdate")},updated(e,t,n,s) {Dt(e,t,n,s,"updated")} }; function xl(e,t) {switch(e) {case "SELECT": return Qr; case "TEXTAREA": return $n; default: switch(t) {case "checkbox": return bl; case "radio": return _l; default: return $n}}} function Dt(e,t,n,s,r) {const o=xl(e.tagName,n.props&&n.props.type)[r]; o&&o(e,t,n,s)} const wl=["ctrl","shift","alt","meta"],Tl={stop: e => e.stopPropagation(),prevent: e => e.preventDefault(),self: e => e.target!==e.currentTarget,ctrl: e => !e.ctrlKey,shift: e => !e.shiftKey,alt: e => !e.altKey,meta: e => !e.metaKey,left: e => "button" in e&&e.button!==0,middle: e => "button" in e&&e.button!==1,right: e => "button" in e&&e.button!==2,exact: (e,t) => wl.some(n => e[`${n}Key`]&&!t.includes(n))},Cl=(e,t) => (n,...s) => {for(let r=0;r<t.length;r++) {const i=Tl[t[r]]; if(i&&i(n,t)) return } return e(n,...s)},vl={esc: "escape",space: " ",up: "arrow-up",left: "arrow-left",right: "arrow-right",down: "arrow-down",delete: "backspace"},El=(e,t) => n => {if(!("key" in n)) return; const s=ot(n.key); if(t.some(r => r===s||vl[r]===s)) return e(n)},Fl=re({patchProp: hl},el); let Ws; function Al() {return Ws||(Ws=So(Fl))} const Il=(...e) => {const t=Al().createApp(...e),{mount: n}=t; return t.mount=s => {const r=Pl(s); if(!r) return; const i=t._component; !M(i)&&!i.render&&!i.template&&(i.template=r.innerHTML),r.innerHTML=""; const o=n(r,!1,r instanceof SVGElement); return r instanceof Element&&(r.removeAttribute("v-cloak"),r.setAttribute("data-v-app","")),o},t}; function Pl(e) {return te(e)? document.querySelector(e):e} const Ml={class: "relative h-6"},Ol=cn({__name: "TimenlineBar",props: {info: null},setup(e) {const t=e; function n(o,l,u,a=0,p=o.length-1) {if(o.length==0||!u(o[p],l)) return p+1; for(;a<p;) {let y=Math.floor((a+p)/2); u(o[y],l)? p=y:a=y+1} return p} let s=Ft(() => {let o=t.info.period.map(l => l[1]); return o.unshift(t.info.start),o}); function r(o,l) {let u=n(s.value,l,(a,p) => a>=p); return u==0||u>=s.value.length? -1:o.period[u-1][0]>=l? 0:u} let i=["#ddd","green","blue","red","orange","yellow"]; return (o,l) => (V(),Y("div",Ml,[L("div",{class: "absolute h-full flex",style: rt({left: `${e.info.start*1.5}rem`})},[(V(!0),Y(G,null,Ke(e.info.end-e.info.start,u => (V(),Y("div",{class: "w-6 border-r border-gray border-solid py-1 bg-clip-content",style: rt({"background-color": q(i)[r(e.info,u+e.info.start)]})},null,4))),256))],4)]))} }); class ft {constructor(t,n,s) {this.name=t,this.arrival=n,this.timeCost=s} responseRatio(t) {return (t-this.arrival)/this.timeCost} } function Rl(e,t,n,s=0,r=e.length-1) {if(e.length==0||!n(e[r],t)) return r+1; for(;s<r;) {let i=Math.floor((s+r)/2); n(e[i],t)? r=i:s=i+1} return r} class is {constructor(t) {de(this,"queue"); de(this,"compare"); this.queue=[],this.compare=t} top() {return this.queue[0]} shift() {return this.queue.shift()} empty() {return this.queue.length==0} push(t) {this.queue.splice(Rl(this.queue,t,this.compare),0,t)} get length() {return this.queue.length} } class kl {constructor() {this.start=-1,this.end=-1,this.period=[]} recStart(t) {this.period.push([t,-1])} recEnd(t) {this.period.at(-1)[1]=t} toString() {let t=0; return this.period.reduce((n,s) => [n[0]+"_".repeat(s[0]-n[1])+`\x1B[${31+t++%6}m`+"@".repeat(s[1]-s[0])+"\x1B[0m",s[1]],[" ".repeat(this.start),this.start])[0]} } class Sl {constructor(t) {de(this,"processList"); de(this,"records"); this.processList=t,this.records=t.map(() => new kl)} start(t,n) {this.records[t].start=n} end(t,n) {this.records[t].end=n} visualize() {let t=this.processList.reduce((s,r) => Math.max(s,r.name.length),0); this.processList.map((s,r) => `${s.name}${" ".repeat(t-s.name.length)} |${this.records[r].toString()}`).forEach(s => console.log(s))} meanJobTurnTime() {return this.records.reduce((t,n) => t+n.end-n.start,0)/this.records.length} meanWeightedJobTurnTime() {return this.records.reduce((t,n,s) => t+(n.end-n.start)/this.processList[s].timeCost,0)/this.records.length} data() {return this.records.map((t,n) => ({name: this.processList[n].name,...t}))} timeSpan() {return this.records.reduce((t,n) => [Math.min(t[0],n.start),Math.max(t[1],n.end)],[0,0])} } var Jt=(e => (e[e.FinishEvent=0]="FinishEvent",e[e.ArrivalEvent=1]="ArrivalEvent",e[e.TimerEvent=2]="TimerEvent",e))(Jt||{}); class os {constructor(t,n) {this.type=n,this.arrival=t} before(t) {return this.arrival==t.arrival? this.type<t.type:this.arrival<t.arrival} } class Ll extends os {constructor(t,n) {super(t,1),this.processId=n} } class hn extends os {constructor(t,n) {super(t,0),this.processId=n} } class Vr extends os {constructor(t,n) {super(t,2),this.wait=n} } class $l extends is {constructor(t) {super((n,s) => s.before(n)),t.forEach(n => this.push(n))} } var ue=(e => (e[e.interrupted=0]="interrupted",e[e.running=1]="running",e[e.ready=2]="ready",e))(ue||{}); class Nl {constructor(t) {this.sysTick=0,this.processorState=2,this.currentWorkingProcessId=-1,this.processList=t.map((n,s) => (n.id=s,n.leftTime=n.timeCost,n)),this.eventQueue=new $l(this.processList.map((n,s) => new Ll(n.arrival,s))),this.recorder=new Sl(this.processList)} work(t) {this.currentWorkingProcessId!=-1&&this.recorder.records[this.currentWorkingProcessId].recEnd(this.sysTick),this.currentWorkingProcessId=t,this.currentWorkingProcessId!=-1&&this.recorder.records[this.currentWorkingProcessId].recStart(this.sysTick)} get workingProcess() {return this.processList[this.currentWorkingProcessId]} } function Hl(e) {for(let t=0;t<e.length;t++)if(e[t]!=0) return e[t]; return e.at(-1)} let Bl={name: "First Come First Served",readyQueue: [],schedule() {return this.readyQueue.shift()} },Ul={name: "Shortest Job First",readyQueue: new is((e,t) => e.timeCost==t.timeCost? e.arrival>t.arrival:e.timeCost>t.timeCost),schedule() {return this.readyQueue.shift()} },jl={name: "Highest Response Ratio First",readyQueue: [],schedule(e) {return this.readyQueue.sort((t,n) => Hl([n.responseRatio(e.sysTick)-t.responseRatio(e.sysTick),t.arrival-n.arrival])),this.readyQueue.shift()} }; class Dl {constructor(t) {de(this,"name"); de(this,"readyQueue"); de(this,"interval"); this.name="Round-Robin",this.interval=t,this.readyQueue=[]} schedule(t) {let n=this.readyQueue.shift(); return n.leftTime>this.interval? t.eventQueue.push(new Vr(t.sysTick+this.interval,this.interval)):t.eventQueue.push(new hn(t.sysTick+n.leftTime,n.id)),n.leftTime-=Math.min(this.interval,n.leftTime),n} handleTimerEvent(t) {t.processorState=ue.interrupted,this.readyQueue.push(t.workingProcess)} handleScheduling(t) {if(t.processorState!=ue.running&&this.readyQueue.length!=0) {t.processorState=ue.running; let n=this.schedule(t); t.work(n.id)} } } class Kl {constructor() {de(this,"name"); de(this,"readyQueue"); this.name="Shortest Remaining Time First",this.readyQueue=new is((t,n) => t.leftTime==n.leftTime? t.arrival>n.arrival:t.leftTime>n.leftTime)} schedule(t) {return this.readyQueue.shift()} handleArrivalEvent(t,n) {var s,r; this.readyQueue.push(n.processList[t]),n.processList[t].leftTime<((r=(s=n.workingProcess)==null? void 0:s.leftTime)!=null? r:0)&&(n.processorState=ue.interrupted)} handleScheduling(t) {if(t.processorState!=ue.running&&this.readyQueue.length!=0) {t.processorState==ue.interrupted&&this.readyQueue.push(t.workingProcess),t.processorState=ue.running; let n=this.schedule(t); t.work(n.id)} (t.eventQueue.empty()||t.sysTick+t.workingProcess.leftTime<=t.eventQueue.top().arrival)&&t.workingProcess.leftTime!=0&&(t.eventQueue.push(new hn(t.sysTick+t.workingProcess.leftTime,t.currentWorkingProcessId)),t.workingProcess.leftTime=0),t.eventQueue.empty()||(t.workingProcess.leftTime-=Math.min(t.eventQueue.top().arrival-t.sysTick,t.workingProcess.leftTime))} } class Ql {constructor(t) {de(this,"name"); de(this,"readyQueues"); de(this,"intervals"); this.name="Multi-Level Feedback Queue",this.intervals=t,this.readyQueues=Array.from(t,() => [])} schedule(t) {for(let n of this.readyQueues) if(n.length!=0) return n.shift()} handleArrivalEvent(t,n) {n.processList[t].priority=0,this.readyQueues[0].push(n.processList[t])} handleTimerEvent(t) {t.processorState=ue.interrupted,t.workingProcess.priority=Math.min(this.qlen-1,t.workingProcess.priority+1),this.readyQueues[t.workingProcess.priority].push(t.workingProcess),t.work(-1)} handleScheduling(t) {if(t.processorState!=ue.running&&this.plen!=0) {t.processorState=ue.running; let n=this.schedule(); t.work(n.id); let s=this.intervals[n.priority]; n.leftTime>s? t.eventQueue.push(new Vr(t.sysTick+s,s)):t.eventQueue.push(new hn(t.sysTick+n.leftTime,n.id)),n.leftTime-=Math.min(s,n.leftTime)} } get plen() {return this.readyQueues.reduce((t,n) => t+n.length,0)} get qlen() {return this.intervals.length} } let Wl=new Ql([1,2,4]),Vl=new Kl,ql=new Dl(1),Vs=[new ft("A",0,3),new ft("B",2,6),new ft("C",4,4),new ft("D",6,5),new ft("E",8,2)]; function zl(e,t) {let n=new Nl(e); for(;!n.eventQueue.empty();) {let s=n.eventQueue.shift(); n.sysTick=s.arrival; let r; switch(s.type) {case Jt.ArrivalEvent: r=s.processId,t.handleArrivalEvent!=null? t.handleArrivalEvent(r,n):t.readyQueue.push(n.processList[r]),n.recorder.start(r,n.sysTick); break; case Jt.FinishEvent: r=s.processId,t.handleFinishEvent!=null&&t.handleFinishEvent(r,n),n.processorState=ue.ready,n.recorder.end(r,n.sysTick); break; case Jt.TimerEvent: t.handleTimerEvent!=null&&t.handleTimerEvent(n); break}if(!(!n.eventQueue.empty()&&n.eventQueue.top().arrival==n.sysTick)) {if(t.handleScheduling!=null) t.handleScheduling(n); else if(n.processorState==ue.ready&&t.readyQueue.length!=0) {n.processorState=ue.running; let i=t.schedule(n); n.work(i.id),n.eventQueue.push(new hn(n.sysTick+i.timeCost,i.id))} } } return n.work(-1),n} var Nn=(e => (e[e.FCFS=0]="FCFS",e[e.SJF=1]="SJF",e[e.HRRF=2]="HRRF",e[e.RR_1=3]="RR_1",e[e.SRTF=4]="SRTF",e[e.MLFQ=5]="MLFQ",e))(Nn||{}); let qr=[Bl,Ul,jl,ql,Vl,Wl]; function Jl(e,t) {return zl(e,qr[t])} const Yl={class: "card"},Xl={class: "flex border-2 border-black border-solid p-2"},Zl={class: "basis-12 shrink-0"},Gl={class: "border-r border-black border-solid"},ec={class: "h-6"},tc={class: "border-t border-gray-400 border-solid"},nc={style: {}},sc={class: "timeline-block relative"},rc={mesh: "",class: "bg flex h-full absolute"},ic={class: "w-6 h-full border-r border-gray border-solid"},oc={class: "flex"},lc=["max","step"],cc=cn({__name: "ProcessTimeline",props: {scheduleStrtegy: null,processData: null,step: null},setup(e) {const t=e; let n=Ft(() => Jl(t.processData,t.scheduleStrtegy).recorder),s=Ft(() => n.value.timeSpan()[1]+2),r=Wt(s.value),i=Ft(() => ({width: `${r.value/t.step*1.5}rem`})); return Vt(s,() => {r.value>s.value&&(r.value=s.value)}),(o,l) => (V(),Y("div",Yl,[L("div",null,Se(q(qr)[e.scheduleStrtegy].name),1),L("div",Xl,[L("div",Zl,[L("div",Gl,[(V(!0),Y(G,null,Ke(q(n).data(),u => (V(),Y("div",ec,Se(u.name),1))),256))]),L("div",tc,Se(q(r)),1)]),L("div",nc,[L("div",sc,[L("div",rc,[(V(!0),Y(G,null,Ke(q(s)/e.step,u => (V(),Y("div",ic))),256))]),L("div",{bars: "",class: "relative top-0 overflow-hidden",style: rt([{width: `${q(s)/e.step*1.5}rem`},{transition: "200ms"}])},[(V(!0),Y(G,null,Ke(q(n).data(),u => (V(),Br(Ol,{info: u},null,8,["info"]))),256))],4),L("div",{cover: "",class: "absolute top-0 h-full border-r border-red-300 border-solid",style: rt(q(i))},null,4)]),L("div",null,[L("div",oc,[es(L("input",{type: "range",min: "0",max: q(s),step: e.step,class: "w-full","onUpdate:modelValue": l[0]||(l[0]=u => ee(r)? r.value=u:r=u)},null,8,lc),[[$n,q(r)]])]),L("div",null,[L("div",null,"\u5E73\u5747\u4F5C\u4E1A\u5468\u8F6C\u65F6\u95F4: "+Se(q(n).meanJobTurnTime()),1),L("div",null,"\u5E73\u5747\u5E26\u6743\u4F5C\u4E1A\u5468\u8F6C\u65F6\u95F4: "+Se(q(n).meanWeightedJobTurnTime()),1)])])])])]))} }),uc={class: "input-table"},fc={key: 0},ac={key: 0},dc=["onKeydown"],hc=["type","onUpdate:modelValue"],pc=cn({__name: "InputTable",props: {caption: null,tableData: null,withindex: {type: Boolean}},setup(e) {function t(n) {n.target.blur()} return (n,s) => (V(),Y("div",null,[L("table",uc,[L("caption",null,Se(e.caption),1),L("thead",null,[L("tr",null,[e.withindex? (V(),Y("th",fc)):ks("",!0),(V(!0),Y(G,null,Ke(e.tableData.head,(r,i) => (V(),Y("th",{key: i},Se(r),1))),128))])]),L("tbody",null,[(V(!0),Y(G,null,Ke(e.tableData.data,(r,i) => (V(),Y("tr",{key: i},[e.withindex? (V(),Y("th",ac,Se(i+1),1)):ks("",!0),(V(!0),Y(G,null,Ke(r,(o,l) => (V(),Y("td",{key: l,onKeydown: El(Cl(t,["prevent"]),["enter"])},[es(L("input",{type: e.tableData.dtype[l]==="number"? "number":"text",class: "cell","onUpdate:modelValue": u => e.tableData.data[i][l]=u},null,8,hc),[[yl,e.tableData.data[i][l]]])],40,dc))),128))]))),128))])])]))} }); const gc={class: "m-10"},mc={class: "flex gap-3 items-stretch"},bc={class: "flex flex-col h-full",style: {"justify-content": "end"}},_c=["value"],yc=cn({__name: "App",setup(e) {let t=Wt(Nn.FCFS),n=Wt(Vs); function s(l) {return l.map(u => [u.name,u.arrival,u.timeCost])} function r(l) {return l.map(u => new ft(...u))} let i=Wt({head: ["name","arrvial","timespan"],dtype: ["string","number","number"],data: s(Vs)}); function o() {n.value.splice(0,n.value.length,...r(i.value.data))} return (l,u) => (V(),Y("div",gc,[L("div",mc,[Ce(pc,{caption: "process","table-data": q(i),withindex: ""},null,8,["table-data"]),L("div",bc,[L("button",{class: "bg-zinc-300 rounded-md p-1 border-solid border border-zinc-600",onClick: o},"update"),L("button",{class: "bg-zinc-300 rounded-md p-1 border-solid border border-zinc-600",onClick: u[0]||(u[0]=a => q(i).data.push([`${q(i).data.length+1}`,0,1]))},"add"),L("button",{class: "bg-zinc-300 rounded-md p-1 border-solid border border-zinc-600",onClick: u[1]||(u[1]=a => q(i).data.pop())},"del")])]),L("div",null,[Ce(cc,{"process-data": q(n),step: 1,"schedule-strtegy": q(t)},null,8,["process-data","schedule-strtegy"]),L("div",null,[jr(" \u8C03\u5EA6\u7B56\u7565: "),es(L("select",{"onUpdate:modelValue": u[2]||(u[2]=a => ee(t)? t.value=a:t=a),name: "",id: ""},[(V(),Y(G,null,Ke(6,a => L("option",{value: a-1},Se(q(Nn)[a-1]),9,_c)),64))],512),[[Qr,q(t)]])])])]))} }); Il(yc).mount("#app");
  </script>
</body>

</html>